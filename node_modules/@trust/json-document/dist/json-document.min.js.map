{"version":3,"sources":["webpack:///json-document.min.js","webpack:///webpack/bootstrap 60daad43a613fa16cf6e","webpack:///./lib/index.js","webpack:///./lib/Formats.js","webpack:///./lib/Initializer.js","webpack:///./lib/JSONDocument.js","webpack:///./lib/JSONPatch.js","webpack:///./lib/JSONPointer.js","webpack:///./lib/JSONMapping.js","webpack:///./lib/JSONSchema.js","webpack:///./lib/Validator.js"],"names":["JSONDocument","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Formats","Initializer","JSONMapping","JSONPatch","JSONPointer","JSONSchema","Validator","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","DATETIME_REGEXP","URI_REGEXP","EMAIL_REGEXP","IPV4_REGEXP","IPV6_REGEXP","HOSTNAME_REGEXP","this","value","name","pattern","Error","RegExp","format","resolve","test","formats","register","initialize","_typeof","Symbol","iterator","obj","constructor","schema","options","assign","root","depth","level","declarations","body","default","properties","items","member","item","declaration","index","block","hasOwnProperty","JSON","stringify","additionalProperties","additionalItems","keys","forEach","subschema","initializer","compile","Array","isArray","_index","Function","e","console","log","stack","data","arguments","undefined","get","alternate","validate","patch","ops","apply","mapping","project","object","parse","SILENT","OPERATIONS","_this","operation","op","indexOf","path","pointer","add","remove","replace","from","match","THROW","RECOVER","expr","mode","tokens","charAt","parseURIFragmentIdentifier","parseJSONString","substr","split","map","unescape","escape","join","decodeURIComponent","token","encodeURIComponent","source","current","push","splice","parseInt","Map","set","right","left","_defineProperty","writeable","isObject","extender","result","indexCount","address","require","validator","required","type","array","number","string","enum","anyOf","allOf","not","oneOf","types","conditions","keywords","validations","constraints","filter","keyword","enumerated","isRequired","segment","validation","pop","patternValidations","additionalValidations","patternProperties","_schema","otherPropertiesCalled","otherProperties","minProperties","maxProperties","dependencies","dependency","_schema2","counter","minItems","maxItems","uniqueItems","minLength","maxLength","matcher","minimum","_schema3","exclusiveMinimum","operator","maximum","_schema4","exclusiveMaximum","multipleOf","toString","decimals","toFixed","pow","Math","condition"],"mappings":"AAAA,GAAIA,cACK,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDOM,SAASI,EAAQD,EAASH,GAE/BI,EAAOD,QAAUH,EAAoB,IAKhC,SAASI,EAAQD,EAASH,GEpDhC,YAEAI,GAAAD,SACAQ,QAAAX,EAAA,GACAY,YAAAZ,EAAA,GACAF,aAAAE,EAAA,GACAa,YAAAb,EAAA,GACAc,UAAAd,EAAA,GACAe,YAAAf,EAAA,GACAgB,WAAAhB,EAAA,GACAiB,UAAAjB,EAAA,KF2DM,SAASI,EAAQD,GGrEvB,YAYA,SAAAe,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAF3F,GAAAC,GAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAC,GAAA,EAAgBA,EAAAD,EAAAE,OAAkBD,IAAA,CAAO,GAAAE,GAAAH,EAAAC,EAA2BE,GAAAC,WAAAD,EAAAC,aAAA,EAAwDD,EAAAE,cAAA,EAAgC,SAAAF,OAAAG,UAAA,GAAuDC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAA+D,gBAAAR,EAAAe,EAAAC,GAA2L,MAAlID,IAAAZ,EAAAH,EAAAiB,UAAAF,GAAqEC,GAAAb,EAAAH,EAAAgB,GAA6DhB,MAIxhBkB,EAAA,uFACAC,EAAA,8CACAC,EAAA,oHACAC,EAAA,4EACAC,EAAA,qpCACAC,EAAA,uFAMAhC,EAAA,WACA,QAAAA,KACAO,EAAA0B,KAAAjC,GAoGA,MAjGAW,GAAAX,IACAuB,IAAA,WAkBAW,MAAA,SAAAC,EAAAC,GAEA,mBAAAD,GACA,SAAAE,OAAA,+BAQA,OAJA,gBAAAD,KACAA,EAAA,GAAAE,QAAAF,IAGAH,KAAAE,GAAAC,KAeAb,IAAA,UACAW,MAAA,SAAAC,GACA,GAAAI,GAAAN,KAAAE,EAEA,KAAAI,EACA,SAAAF,OAAA,8BAGA,OAAAE,MAeAhB,IAAA,OACAW,MAAA,SAAAC,EAAAD,GACA,GAAAK,GAAAN,KAAAO,QAAAL,EACA,OAAAI,GAAAE,KAAAP,QAGAX,IAAA,aAWAW,MAAA,WACA,GAAAQ,GAAA,GAAA1C,EAOA,OANA0C,GAAAC,SAAA,YAAAhB,GACAe,EAAAC,SAAA,MAAAf,GACAc,EAAAC,SAAA,QAAAd,GACAa,EAAAC,SAAA,OAAAb,GACAY,EAAAC,SAAA,OAAAZ,GACAW,EAAAC,SAAA,WAAAX,GACAU,MAIA1C,IAQAP,GAAAD,QAAAQ,EAAA4C,cH2EM,SAASnD,EAAQD,GIlNvB,YAUA,SAAAe,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAJ3F,GAAAmC,GAAA,kBAAAC,SAAA,gBAAAA,QAAAC,SAAA,SAAAC,GAAoG,aAAAA,IAAqB,SAAAA,GAAmB,MAAAA,IAAA,kBAAAF,SAAAE,EAAAC,cAAAH,QAAAE,IAAAF,OAAApB,UAAA,eAAAsB,IAE5IrC,EAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAC,GAAA,EAAgBA,EAAAD,EAAAE,OAAkBD,IAAA,CAAO,GAAAE,GAAAH,EAAAC,EAA2BE,GAAAC,WAAAD,EAAAC,aAAA,EAAwDD,EAAAE,cAAA,EAAgC,SAAAF,OAAAG,UAAA,GAAuDC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAA+D,gBAAAR,EAAAe,EAAAC,GAA2L,MAAlID,IAAAZ,EAAAH,EAAAiB,UAAAF,GAAqEC,GAAAb,EAAAH,EAAAgB,GAA6DhB,MAIxhBR,EAAA,WAKA,QAAAA,GAAAiD,EAAAC,GACA5C,EAAA0B,KAAAhC,GAEAoB,OAAA+B,OAAAnB,KAAAkB,OACAlB,KAAAoB,KAAApB,KAAAoB,MAAApB,KAEAA,KAAAoB,KAAAC,MAAArB,KAAAoB,KAAAC,OAAA,EAEArB,KAAAsB,MAAAtB,KAAAoB,KAAAC,QACArB,KAAAoB,KAAAC,MAAArB,KAAAsB,OAGAtB,KAAAsB,MAAAtB,KAAAsB,OAAA,EACAtB,KAAAiB,SA4RA,MApRAvC,GAAAV,IACAsB,IAAA,UAMAW,MAAA,WACA,GAAAmB,GAAApB,KAAAoB,KAIAG,GAHAvB,KAAAqB,MACArB,KAAAsB,MAEA,IACAE,EAAA,EAgBA,IAbAA,GAAAxB,KAAAyB,UACAD,GAAAxB,KAAA0B,aAEAF,GAAAxB,KAAA2B,QAKAH,GAAAxB,KAAA4B,SACAJ,GAAAxB,KAAA6B,OAIAT,IAAApB,KAAA,CACA,OAAAlB,GAAA,EAAuBA,GAAAkB,KAAAoB,KAAAC,MAAsBvC,IAC7CyC,GAAAvB,KAAA8B,YAAAhD,EAGA,kLAA4KyC,EAAA,aAAAC,EAAA,WAG5K,MAAAA,MAQAlC,IAAA,cACAW,MAAA,SAAAqB,GACA,2BAAAA,EAAA,qBAAAA,EAAA,oBAAAA,EAAA,YAQAhC,IAAA,UACAW,MAAA,WACA,GAAAgB,GAAAjB,KAAAiB,OACAK,EAAAtB,KAAAsB,MACAhC,EAAAU,KAAAV,IACAyC,EAAA/B,KAAA+B,MACA9B,EAAAgB,EAAAQ,QAEAO,EAAA,EAmBA,OAjBAf,GAAAgB,eAAA,aAEA3C,IACA0C,GAAA,qBAAAV,EAAA,KAAAhC,EAAA,QAAA4C,KAAAC,UAAAlC,GAAA,cAGA8B,IACAC,GAAA,qBAAAV,EAAA,IAAAS,EAAA,OAAAG,KAAAC,UAAAlC,GAAA,cAGAqB,EAAA,IACAU,GAAA,oBAAAV,EAAA,gBAGAU,EAAA,0DAA4DA,EAAA,uBAG5DA,KAQA1C,IAAA,SACAW,MAAA,WACA,GAAAgB,GAAAjB,KAAAiB,OAEAK,GADAtB,KAAAoB,KACApB,KAAAsB,OACAhC,EAAAU,KAAAV,IACAoC,EAAAT,EAAAS,WACAU,EAAAnB,EAAAmB,qBACAT,EAAAV,EAAAU,MACAU,EAAApB,EAAAoB,gBAEAL,EAAA,EAmBA,QAdA1C,GAAAoC,GAAAU,GAAAT,GAAAU,IAGAL,GAAA,mBAAAV,EAAA,KAAAhC,EAAA,cAAAgC,EAAA,KAAAhC,EAAA,aAGAgC,EAAA,IACAU,GAAA,oBAAAV,EAAA,gBAIAU,EAAA,uBAAAV,EAAA,oBAAAhC,EAAA,oBAAqF0C,EAAA,uBAGrFA,KAQA1C,IAAA,OACAW,MAAA,WACA,GAAAgB,GAAAjB,KAAAiB,OAEAK,GADAtB,KAAAoB,KACApB,KAAAsB,OACAS,EAAA/B,KAAA+B,MACAL,EAAAT,EAAAS,WACAU,EAAAnB,EAAAmB,qBACAT,EAAAV,EAAAU,MACAU,EAAApB,EAAAoB,gBAEAL,EAAA,EAaA,QAXAD,GAAAL,GAAAU,GAAAT,GAAAU,IAEAL,GAAA,mBAAAV,EAAA,IAAAS,EAAA,aAAAT,EAAA,IAAAS,EAAA,YAEAT,EAAA,IACAU,GAAA,oBAAAV,EAAA,gBAGAU,EAAA,iBAAAD,EAAA,wBAAqDC,EAAA,uBAGrDA,KAQA1C,IAAA,aACAW,MAAA,QAAAyB,KACA,GAAAT,GAAAjB,KAAAiB,OACAG,EAAApB,KAAAoB,KACAE,EAAAtB,KAAAsB,MACAhC,EAAAU,KAAAV,IACAyC,EAAA/B,KAAA+B,MACAL,EAAAT,EAAAS,WAEAM,EAAA,EA2BA,OAzBAN,KACAtC,OAAAkD,KAAAZ,GAAAa,QAAA,SAAAjD,GACA,GAAAkD,GAAAd,EAAApC,GACAmD,EAAA,GAAAzE,GAAAwE,GAAwDlD,MAAA8B,OAAAE,QAAA,GAExDU,IAAAS,EAAAC,YAIAtB,IAAApB,KACAgC,EAAA,qSAAqNA,EAAA,2BAKrND,IACAC,EAAA,qBAAAD,EAAA,YAAAT,EAAA,2BAAAA,EAAA,IAAAS,EAAA,6CAAgJT,EAAA,eAAAA,EAAA,IAAAS,EAAA,gCAAsFT,EAAA,gCAAAS,EAAA,YAAAT,EAAA,2BAAAA,EAAA,IAAAS,EAAA,6CAA2KT,EAAA,iCAAgDS,EAAA,YAAAT,EAAA,uCAAmEA,EAAA,4EAAyFA,EAAA,eAAAA,EAAA,IAAAS,EAAA,uCAAiGC,EAAA,+BAAAV,EAAA,qCAAoFA,EAAA,IAAAS,EAAA,cAAAT,EAAA,6BAAAA,EAAA,oEAA+JA,EAAA,IAAAS,EAAA,aAAAT,EAAA,IAAAS,EAAA,yBAAAT,EAAA,iCAGj7BhC,IACA0C,EAAA,mCAAAV,EAAA,KAAAhC,EAAA,+CAAAgC,EAAA,KAAAhC,EAAA,0DAAAgC,EAAA,KAAAhC,EAAA,mCAAAgC,EAAA,oBAAAhC,EAAA,iCAA8TgC,EAAA,eAAAA,EAAA,KAAAhC,EAAA,iCAAwFgC,EAAA,uCAAAA,EAAA,oBAAAhC,EAAA,yCAAAgC,EAAA,KAAAhC,EAAA,+CAAAgC,EAAA,KAAAhC,EAAA,yDAAAgC,EAAA,KAAAhC,EAAA,kCAAwVgC,EAAA,uCAAgDA,EAAA,oBAAAhC,EAAA,kCAA4EgC,EAAA,4EAAyFA,EAAA,eAAAA,EAAA,KAAAhC,EAAA,6BAAAgC,EAAA,2CAA+IU,EAAA,+BAAAV,EAAA,qCAAoFA,EAAA,KAAAhC,EAAA,eAAAgC,EAAA,6BAAAA,EAAA,oEAAiKA,EAAA,KAAAhC,EAAA,cAAAgC,EAAA,KAAAhC,EAAA,0BAAAgC,EAAA,mCAKv0CU,KAQA1C,IAAA,uBACAW,MAAA,eAOAX,IAAA,QACAW,MAAA,QAAA0B,KACA,GAAAV,GAAAjB,KAAAiB,OACAG,EAAApB,KAAAoB,KACAE,EAAAtB,KAAAsB,MACAhC,EAAAU,KAAAV,IAEAqC,GADA3B,KAAA+B,MACAd,EAAAU,OAEAK,EAAA,EAEA,IAAAL,EAAA,CAEA,GAAAgB,MAAAC,QAAAjB,QASS,mCAAAA,GAAA,YAAAf,EAAAe,KAAA,OAAAA,EAAA,CACT,GAAAkB,GAAA,KAAAvB,EAAA,GACAmB,EAAA,GAAAzE,GAAA2D,GAAoDI,MAAAc,EAAAzB,OAAAE,QAAA,GAEpDU,IAAA,iCAAAV,EAAA,gDAAAA,EAAA,kcAAqiBuB,EAAA,SAA0CA,EAAA,WAAsBA,EAAA,sBAAoBJ,EAAAC,UAAA,0BAKznBV,EADAZ,IAAApB,KACA,uNAA2JgC,EAAA,0BAI3J,uCAAAV,EAAA,KAAAhC,EAAA,iBAAAgC,EAAA,oBAAAhC,EAAA,+BAAiJgC,EAAA,eAAAA,EAAA,KAAAhC,EAAA,+BAAAgC,EAAA,qCAAAA,EAAA,oBAAAhC,EAAA,8BAAAgC,EAAA,KAAAhC,EAAA,gCAAmQgC,EAAA,uCAAAA,EAAA,oBAAAhC,EAAA,kCAA0HgC,EAAA,0EAAyFA,EAAA,eAAAA,EAAA,KAAAhC,EAAA,2BAAAgC,EAAA,uCAAyIU,EAAA,6BAAAV,EAAA,mCAAgFA,EAAA,KAAAhC,EAAA,eAAAgC,EAAA,2BAAAA,EAAA,8DAAyJA,EAAA,KAAAhC,EAAA,cAAAgC,EAAA,KAAAhC,EAAA,wBAAAgC,EAAA,4BAIz9B,MAAAU,MAQA1C,IAAA,kBACAW,MAAA,iBAEAX,IAAA,UACAW,MAAA,SAAAgB,GACA,GAAAwB,GAAA,GAAAzE,GAAAiD,GACAe,EAAAS,EAAAC,SAGA,KACA,UAAAI,UAAA,4BAAAd,GACO,MAAAe,GACPC,QAAAC,IAAAF,IAAAG,YAKAlF,IAGAR,GAAAD,QAAAS,GJwNM,SAASR,EAAQD,EAASH,GKrhBhC,YASA,SAAAkB,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAF3F,GAAAC,GAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAC,GAAA,EAAgBA,EAAAD,EAAAE,OAAkBD,IAAA,CAAO,GAAAE,GAAAH,EAAAC,EAA2BE,GAAAC,WAAAD,EAAAC,aAAA,EAAwDD,EAAAE,cAAA,EAAgC,SAAAF,OAAAG,UAAA,GAAuDC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAA+D,gBAAAR,EAAAe,EAAAC,GAA2L,MAAlID,IAAAZ,EAAAH,EAAAiB,UAAAF,GAAqEC,GAAAb,EAAAH,EAAAgB,GAA6DhB,MAIxhBN,EAAAd,EAAA,GAUAF,EAAA,WAqBA,QAAAA,KACA,GAAAiG,GAAAC,UAAArE,OAAA,GAAAsE,SAAAD,UAAA,GAAAA,UAAA,MACAlC,EAAAkC,UAAArE,OAAA,GAAAsE,SAAAD,UAAA,GAAAA,UAAA,KAEA9E,GAAA0B,KAAA9C,GAEA8C,KAAAW,WAAAwC,EAAAjC,GA2HA,MArJAxC,GAAAxB,EAAA,OACAoC,IAAA,SAMAgE,IAAA,WACA,SAAAlD,OAAA,gEA6BA1B,EAAAxB,IACAoC,IAAA,aACAW,MAAA,WACA,GAAAkD,GAAAC,UAAArE,OAAA,GAAAsE,SAAAD,UAAA,GAAAA,UAAA,MACAlC,EAAAkC,UAAArE,OAAA,GAAAsE,SAAAD,UAAA,GAAAA,UAAA,MACAnC,EAAAjB,KAAAgB,YAAAC,MAEAA,GAAAN,WAAAX,KAAAmD,EAAAjC,MAWA5B,IAAA,WACAW,MAAA,SAAAsD,GACA,GAAAtC,GAAAjB,KAAAgB,YAAAC,MAEA,QAAAsC,GAAAtC,GAAAuC,SAAAxD,SAUAV,IAAA,QACAW,MAAA,QAAAwD,GAAAC,GACA,GAAAD,GAAA,GAAAvF,GAAAwF,EACAD,GAAAE,MAAA3D,SAQAV,IAAA,SACAW,MAAA,eAgCAX,IAAA,UACAW,MAAA,SAAA2D,GACA,MAAAA,GAAAC,QAAA7D,WAWAV,IAAA,YACAW,MAAA,SAAA6D,GACA,MAAA5B,MAAAC,UAAA2B,MAWAxE,IAAA,cACAW,MAAA,SAAAkD,GACA,IACA,MAAAjB,MAAA6B,MAAAZ,GACO,MAAAJ,GACP,SAAA3C,OAAA,6BAKAlD,IAQAM,GAAAD,QAAAL,GL2hBM,SAASM,EAAQD,EAASH,GM9sBhC,YAWA,SAAAkB,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAJ3F,GAAAmC,GAAA,kBAAAC,SAAA,gBAAAA,QAAAC,SAAA,SAAAC,GAAoG,aAAAA,IAAqB,SAAAA,GAAmB,MAAAA,IAAA,kBAAAF,SAAAE,EAAAC,cAAAH,QAAAE,IAAAF,OAAApB,UAAA,eAAAsB,IAE5IrC,EAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAC,GAAA,EAAgBA,EAAAD,EAAAE,OAAkBD,IAAA,CAAO,GAAAE,GAAAH,EAAAC,EAA2BE,GAAAC,WAAAD,EAAAC,aAAA,EAAwDD,EAAAE,cAAA,EAAgC,SAAAF,OAAAG,UAAA,GAAuDC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAA+D,gBAAAR,EAAAe,EAAAC,GAA2L,MAAlID,IAAAZ,EAAAH,EAAAiB,UAAAF,GAAqEC,GAAAb,EAAAH,EAAAgB,GAA6DhB,MAIxhBL,EAAAf,EAAA,GAOA4G,EAAA,EAKAC,GAAA,+CAUA/F,EAAA,WAOA,QAAAA,GAAAwF,GACApF,EAAA0B,KAAA9B,GAEA8B,KAAA0D,UAuKA,MAzJAhF,GAAAR,IACAoB,IAAA,QACAW,MAAA,SAAArB,GACA,GAAAsF,GAAAlE,IAEAA,MAAA0D,IAAAnB,QAAA,SAAA4B,GACA,GAAAC,GAAAD,EAAAC,EAEA,KAAAA,EACA,SAAAhE,OAAA,uCAGA,IAAA6D,EAAAI,QAAAD,MAAA,EACA,SAAAhE,OAAA,uCAGA,KAAA+D,EAAAG,KACA,SAAAlE,OAAA,yCAGA8D,GAAAE,GAAAD,EAAAvF,QAYAU,IAAA,MACAW,MAAA,SAAAmE,EAAAxF,GACA,GAAAyE,SAAAe,EAAAnE,MACA,SAAAG,OAAA,8CAGA,IAAAmE,GAAA,GAAApG,GAAAiG,EAAAE,KAAAN,EACAO,GAAAC,IAAA5F,EAAAwF,EAAAnE,UAWAX,IAAA,SACAW,MAAA,SAAAmE,EAAAxF,GACA,GAAA2F,GAAA,GAAApG,GAAAiG,EAAAE,KACAC,GAAAE,OAAA7F,MAWAU,IAAA,UACAW,MAAA,SAAAmE,EAAAxF,GACA,GAAAyE,SAAAe,EAAAnE,MACA,SAAAG,OAAA,kDAGA,IAAAmE,GAAA,GAAApG,GAAAiG,EAAAE,KACAC,GAAAG,QAAA9F,EAAAwF,EAAAnE,UAWAX,IAAA,OACAW,MAAA,SAAAmE,EAAAxF,GACA,GAAAyE,SAAAe,EAAAO,KACA,SAAAvE,OAAA,8CAGA,IAAAgE,EAAAE,KAAAM,MAAA,GAAAvE,QAAA,IAAA+D,EAAAO,OACA,SAAAvE,OAAA,8CAGA,IAAAmE,GAAA,GAAApG,GAAAiG,EAAAE,MACAK,EAAA,GAAAxG,GAAAiG,EAAAO,MACA1E,EAAA0E,EAAArB,IAAA1E,EAEA+F,GAAAF,OAAA7F,GACA2F,EAAAC,IAAA5F,EAAAqB,MAWAX,IAAA,OACAW,MAAA,SAAAmE,EAAAxF,GACA,GAAAyE,SAAAe,EAAAO,KACA,SAAAvE,OAAA,8CAGA,IAAAmE,GAAA,GAAApG,GAAAiG,EAAAE,MACAK,EAAA,GAAAxG,GAAAiG,EAAAO,MACA1E,EAAA0E,EAAArB,IAAA1E,EAEA2F,GAAAC,IAAA5F,EAAAqB,MAWAX,IAAA,OACAW,MAAA,SAAAmE,EAAAxF,GACA,GAAAyE,SAAAe,EAAAnE,MACA,SAAAG,OAAA,+CAGA,IAAAmE,GAAA,GAAApG,GAAAiG,EAAAE,MACArE,EAAAsE,EAAAjB,IAAA1E,EAEA,QAAAgC,EAAAwD,EAAAnE,QAOA,QACA,GAAAA,IAAAmE,EAAAnE,MACA,SAAAG,OAAA,0CAMAlC,IAQAV,GAAAD,QAAAW,GNotBM,SAASV,EAAQD,GOh7BvB,YAQA,SAAAe,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAF3F,GAAAC,GAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAC,GAAA,EAAgBA,EAAAD,EAAAE,OAAkBD,IAAA,CAAO,GAAAE,GAAAH,EAAAC,EAA2BE,GAAAC,WAAAD,EAAAC,aAAA,EAAwDD,EAAAE,cAAA,EAAgC,SAAAF,OAAAG,UAAA,GAAuDC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAA+D,gBAAAR,EAAAe,EAAAC,GAA2L,MAAlID,IAAAZ,EAAAH,EAAAiB,UAAAF,GAAqEC,GAAAb,EAAAH,EAAAgB,GAA6DhB,MAIxhBqG,EAAA,EACAC,EAAA,EACAd,EAAA,EAUA7F,EAAA,WAKA,QAAAA,GAAA4G,EAAAC,GACA1G,EAAA0B,KAAA7B,GAEA6B,KAAA+E,OACA/E,KAAAgF,QAAAH,EACA7E,KAAAiF,OAAAF,GAAA,MAAAA,EAAAG,OAAA,GAAAlF,KAAAmF,2BAAAJ,GAAA/E,KAAAoF,gBAAAL,GAgQA,MAxPArG,GAAAP,IACAmB,IAAA,SACAW,MAAA,SAAA8E,GACA,MAAAA,GAAAL,QAAA,WAAAA,QAAA,eAQApF,IAAA,WACAW,MAAA,SAAA8E,GACA,MAAAA,GAAAL,QAAA,WAAAA,QAAA,cAQApF,IAAA,kBAUAW,MAAA,SAAA8E,GACA,mBAAAA,GACA,SAAA3E,OAAA,gCAGA,SAAA2E,EACA,QAGA,UAAAA,EAAAG,OAAA,GACA,SAAA9E,OAAA,uBAGA,aAAA2E,GACA,IAGAA,EAAAM,OAAA,GAAAC,MAAA,KAAAC,IAAAvF,KAAAwF,aAWAlG,IAAA,eACAW,MAAA,WACA,UAAAD,KAAAiF,OAAAM,IAAAvF,KAAAyF,QAAAC,KAAA,QAQApG,IAAA,6BACAW,MAAA,SAAA8E,GACA,mBAAAA,GACA,SAAA3E,OAAA,gCAGA,UAAA2E,EAAAG,OAAA,GACA,SAAA9E,OAAA,+CAGA,OAAAJ,MAAAoF,gBAAAO,mBAAAZ,EAAAM,OAAA,QAWA/F,IAAA,0BACAW,MAAA,WACA,GAAAiE,GAAAlE,KAEAC,EAAAD,KAAAiF,OAAAM,IAAA,SAAAK,GACA,MAAAC,oBAAA3B,EAAAuB,OAAAG,MACOF,KAAA,IAEP,YAAAzF,KAYAX,IAAA,MACAW,MAAA,SAAA6F,GAIA,OAHAC,GAAAD,EACAb,EAAAjF,KAAAiF,OAEAnG,EAAA,EAAqBA,EAAAmG,EAAAlG,OAAmBD,IAAA,CACxC,IAAAiH,GAAA1C,SAAA0C,EAAAd,EAAAnG,IAAA,CACA,GAAAkB,KAAAgF,OAAAH,EACA,MAEA,UAAAzE,OAAA,kCAIA2F,IAAAd,EAAAnG,IAGA,MAAAiH,MAcAzG,IAAA,MACAW,MAAA,SAAArB,EAAAqB,GAKA,OAJAgF,GAAAjF,KAAAiF,OACAc,EAAAnH,EAGAE,EAAA,EAAqBA,EAAAmG,EAAAlG,OAAmBD,IAAA,CACxC,GAAA8G,GAAAX,EAAAnG,EAGA,IAAAA,IAAAmG,EAAAlG,OAAA,EACA,MAAA6G,EACAG,EAAAC,KAAA/F,GACW0C,MAAAC,QAAAmD,GACXA,EAAAE,OAAAL,EAAA,EAAA3F,GACWoD,SAAApD,IACX8F,EAAAH,GAAA3F,OAIS,IAAA8F,EAAAH,GAkBTG,IAAAH,OAjBA,QAAA5F,KAAAgF,MACA,IAAAH,GACA,SAAAzE,OAAA,iCAEA,KAAA0E,GACAiB,IAAAH,GAAAM,SAAAN,QACA,MAEA,KAAA5B,GACA,MAEA,SACA,SAAA5D,OAAA,6BAoBAd,IAAA,UACAW,MAAA,SAAArB,EAAAqB,GAIA,OAHAgF,GAAAjF,KAAAiF,OACAc,EAAAnH,EAEAE,EAAA,EAAqBA,EAAAmG,EAAAlG,OAAmBD,IAAA,CACxC,GAAA8G,GAAAX,EAAAnG,EAEAA,KAAAmG,EAAAlG,OAAA,EACAgH,EAAAH,GAAA3F,EAIA8F,EAHSA,EAAAH,GAGTG,EAAAH,GAFAG,EAAAH,GAAAM,SAAAN,aAcAtG,IAAA,SACAW,MAAA,SAAArB,GAIA,OAHAqG,GAAAjF,KAAAiF,OACAc,EAAAnH,EAEAE,EAAA,EAAqBA,EAAAmG,EAAAlG,OAAmBD,IAAA,CACxC,GAAA8G,GAAAX,EAAAnG,EAEA,IAAAuE,SAAA0C,GAAA1C,SAAA0C,EAAAH,GACA,MACS,IAAAjD,MAAAC,QAAAmD,GAET,WADAA,GAAAE,OAAAL,EAAA,EAES9G,KAAAmG,EAAAlG,OAAA,SACTgH,GAAAH,GAGAG,IAAAH,SAMAtG,IAAA,QACAW,MAAA,SAAA8E,GACA,UAAA5G,GAAA4G,OAIA5G,IAQAX,GAAAD,QAAAY,GPs7BM,SAASX,EAAQD,EAASH,GQ9tChC,YASA,SAAAkB,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAF3F,GAAAC,GAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAC,GAAA,EAAgBA,EAAAD,EAAAE,OAAkBD,IAAA,CAAO,GAAAE,GAAAH,EAAAC,EAA2BE,GAAAC,WAAAD,EAAAC,aAAA,EAAwDD,EAAAE,cAAA,EAAgC,SAAAF,OAAAG,UAAA,GAAuDC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAA+D,gBAAAR,EAAAe,EAAAC,GAA2L,MAAlID,IAAAZ,EAAAH,EAAAiB,UAAAF,GAAqEC,GAAAb,EAAAH,EAAAgB,GAA6DhB,MAIxhBL,EAAAf,EAAA,GAKA0H,EAAA,EAUA7G,EAAA,WAQA,QAAAA,GAAA2F,GACA,GAAAM,GAAAlE,IAEA1B,GAAA0B,KAAA/B,GAEAmB,OAAAC,eAAAW,KAAA,WACAf,YAAA,EACAgB,MAAA,GAAAkG,OAGA/G,OAAAkD,KAAAsB,GAAArB,QAAA,SAAAjD,GACA,GAAAW,GAAA2D,EAAAtE,EACA4E,GAAAN,QAAAwC,IAAA,GAAAjI,GAAAmB,EAAAwF,GAAA,GAAA3G,GAAA8B,EAAA6E,MAwCA,MA1BApG,GAAAT,IACAqB,IAAA,MACAW,MAAA,SAAArB,EAAAkH,GACA9F,KAAA4D,QAAArB,QAAA,SAAA8D,EAAAC,GACAA,EAAA9B,IAAA5F,EAAAyH,EAAA/C,IAAAwC,SAcAxG,IAAA,UACAW,MAAA,SAAA6F,EAAAlH,GACAoB,KAAA4D,QAAArB,QAAA,SAAA8D,EAAAC,GACAD,EAAA7B,IAAA5F,EAAA0H,EAAAhD,IAAAwC,UAKA7H,IAQAT,GAAAD,QAAAU,GRouCM,SAAST,EAAQD,EAASH,GSl0ChC,YAWA,SAAAmJ,GAAAxF,EAAAzB,EAAAW,GAAmM,MAAxJX,KAAAyB,GAAkB3B,OAAAC,eAAA0B,EAAAzB,GAAkCW,QAAAhB,YAAA,EAAAC,cAAA,EAAAC,UAAA,IAAgF4B,EAAAzB,GAAAW,EAAoBc,EAEnM,QAAAzC,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAN3F,GAAAmC,GAAA,kBAAAC,SAAA,gBAAAA,QAAAC,SAAA,SAAAC,GAAoG,aAAAA,IAAqB,SAAAA,GAAmB,MAAAA,IAAA,kBAAAF,SAAAE,EAAAC,cAAAH,QAAAE,IAAAF,OAAApB,UAAA,eAAAsB,IAE5IrC,EAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAC,GAAA,EAAgBA,EAAAD,EAAAE,OAAkBD,IAAA,CAAO,GAAAE,GAAAH,EAAAC,EAA2BE,GAAAC,WAAAD,EAAAC,aAAA,EAAwDD,EAAAE,cAAA,EAAgC,SAAAF,OAAAG,UAAA,GAAuDC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAA+D,gBAAAR,EAAAe,EAAAC,GAA2L,MAAlID,IAAAZ,EAAAH,EAAAiB,UAAAF,GAAqEC,GAAAb,EAAAH,EAAAgB,GAA6DhB,MAMxhBR,EAAAZ,EAAA,GACAiB,EAAAjB,EAAA,GAUAgB,EAAA,WAOA,QAAAA,GAAA6C,GACA3C,EAAA0B,KAAA5B,GAGAgB,OAAA+B,OAAAnB,KAAAiB,GAGA7B,OAAAT,iBAAAqB,MACAW,YACA1B,YAAA,EACAuH,WAAA,EACAvG,MAAAjC,EAAA0E,QAAAzB,IAEAuC,UACAvE,YAAA,EACAuH,WAAA,EACAvG,MAAA5B,EAAAqE,QAAAzB,MAqDA,MA9BAvC,GAAAN,IACAkB,IAAA,SACAW,MAAA,SAAAgB,GACA,QAAAwF,GAAAtD,GACA,MAAAA,IAAA,+BAAAA,GAAA,YAAAvC,EAAAuC,KAAA,OAAAA,IAAAR,MAAAC,QAAAO,GAGA,QAAAuD,GAAA9H,EAAAkH,GACA,GAAAa,GAAAvH,OAAA+B,UAAqCvC,EAcrC,OAbA6H,GAAA7H,IAAA6H,EAAAX,IACA1G,OAAAkD,KAAAwD,GAAAvD,QAAA,SAAAjD,GACAmH,EAAAX,EAAAxG,KACAA,IAAAV,GAGA+H,EAAArH,GAAAoH,EAAA9H,EAAAU,GAAAwG,EAAAxG,IAGAF,OAAA+B,OAAAwF,EAAAJ,KAAsDjH,EAAAwG,EAAAxG,OAItDqH,EAGA,GAAA3H,GAAA0H,EAAA1G,KAAAiB,EACA,WAAA7C,GAAAY,OAIAZ,IAQAZ,GAAAD,QAAAa,GTw0CM,SAASZ,EAAQD,EAASH,GUt7ChC,YAWA,SAAAkB,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAJ3F,GAAAmC,GAAA,kBAAAC,SAAA,gBAAAA,QAAAC,SAAA,SAAAC,GAAoG,aAAAA,IAAqB,SAAAA,GAAmB,MAAAA,IAAA,kBAAAF,SAAAE,EAAAC,cAAAH,QAAAE,IAAAF,OAAApB,UAAA,eAAAsB,IAE5IrC,EAAA,WAAgC,QAAAC,GAAAC,EAAAC,GAA2C,OAAAC,GAAA,EAAgBA,EAAAD,EAAAE,OAAkBD,IAAA,CAAO,GAAAE,GAAAH,EAAAC,EAA2BE,GAAAC,WAAAD,EAAAC,aAAA,EAAwDD,EAAAE,cAAA,EAAgC,SAAAF,OAAAG,UAAA,GAAuDC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAA+D,gBAAAR,EAAAe,EAAAC,GAA2L,MAAlID,IAAAZ,EAAAH,EAAAiB,UAAAF,GAAqEC,GAAAb,EAAAH,EAAAgB,GAA6DhB,MAIxhBiC,EAAArD,EAAA,GAOAwJ,EAAA,EAQAvI,EAAA,WA2CA,QAAAA,GAAA4C,GACA,GAAAC,GAAAkC,UAAArE,OAAA,GAAAsE,SAAAD,UAAA,GAAAA,UAAA,KAEA9E,GAAA0B,KAAA3B,GAGA2B,KAAAiB,SAGA7B,OAAA+B,OAAAnB,KAAAkB,GAGAlB,KAAA6G,UACA7G,KAAA6G,QAAA,IAIA7G,KAAA8G,WAAA,IACA9G,KAAA8G,SAAA,GAymCA,MArqCApI,GAAAL,EAAA,OACAiB,IAAA,UAYAW,MAAA,SAAAgB,GACA,GAAA8F,GAAA,GAAA1I,GAAA4C,GAEAO,EAAA,kZAAAuF,EAAArE,UAAA,+FAEA,WAAAI,UAAA,OAAAtB,MAUAlC,IAAA,UACAgE,IAAA,WACA,MAAAsD,SAkDAlI,EAAAL,IACAiB,IAAA,UACAW,MAAA,WACA,GAAA+B,GAAA,EAwBA,OAtBAhC,MAAA8G,UACA9E,GAAAhC,KAAAgH,YAIAhF,GAAAhC,KAAAiH,OAKAjF,GAAAhC,KAAAkH,QACAlF,GAAAhC,KAAAmH,SACAnF,GAAAhC,KAAA8D,SACA9B,GAAAhC,KAAAoH,SAGApF,GAAAhC,KAAAqH,OACArF,GAAAhC,KAAAsH,QACAtF,GAAAhC,KAAAuH,QACAvF,GAAAhC,KAAAwH,MACAxF,GAAAhC,KAAAyH,WAUAnI,IAAA,OACAW,MAAA,WACA,iFAQAX,IAAA,MACAW,MAAA,WACA,sIAeAX,IAAA,OACAW,MAAA,QAAAgH,KACA,GAAAA,GAAAjH,KAAAiB,OAAAgG,KACAJ,EAAA7G,KAAA6G,QAEA7E,EAAA,EAEA,IAAAiF,EAAA,CACA,GAAAS,GAAA/E,MAAAC,QAAAqE,SACAU,EAAAD,EAAAnC,IAAA,SAAA0B,GAEA,gBAAAA,EAAA,wBACA,YAAAA,EAAA,6BACA,YAAAA,EAAA,2BACA,SAAAA,EAAA,iBACA,WAAAA,EAAA,4BACA,WAAAA,EAAA,wEACA,WAAAA,EAAA,qCACSvB,KAAA,OAET1D,IAAA,cAAA6E,EAAA,oDAAAc,EAAA,gJAGA,MAAA3F,MA6CA1C,IAAA,QACAW,MAAA,WACA,GAAA2H,IAAA,+DACAC,EAAA7H,KAAA6H,YAAAD,GACA5F,EAAA,EAMA,OAJA6F,GAAA9I,OAAA,IACAiD,GAAA,gGAAuG6F,EAAA,qBAGvG7F,KAeA1C,IAAA,SACAW,MAAA,WACA,GAAA2H,IAAA,kCACAC,EAAA7H,KAAA6H,YAAAD,GACA5F,EAAA,EAMA,OAJA6F,GAAA9I,OAAA,IACAiD,GAAA,sGAA+G6F,EAAA,qBAG/G7F,KAeA1C,IAAA,SACAW,MAAA,WACA,GAAA2H,IAAA,oJACAC,EAAA7H,KAAA6H,YAAAD,GACA5F,EAAA,EAMA,OAJA6F,GAAA9I,OAAA,IACAiD,GAAA,iJAA0J6F,EAAA,qBAG1J7F,KAeA1C,IAAA,SACAW,MAAA,WACA,GAAA2H,IAAA,4CACAC,EAAA7H,KAAA6H,YAAAD,GACA5F,EAAA,EAMA,OAJA6F,GAAA9I,OAAA,IACAiD,GAAA,sGAA+G6F,EAAA,qBAG/G7F,KAgBA1C,IAAA,cACAW,MAAA,SAAA2H,GACA,GAAA1D,GAAAlE,KAEAiB,EAAAjB,KAAAiB,OAEAe,EAAA,GAEA8F,EAAA1I,OAAAkD,KAAArB,GAAA8G,OAAA,SAAAzI,GACA,MAAAsI,GAAAvD,QAAA/E,MAAA,GAOA,OAJAwI,GAAAvF,QAAA,SAAAyF,GACAhG,GAAAkC,EAAA8D,OAGAhG,KAeA1C,IAAA,OACAW,MAAA,WACA,GAAAgI,GAAAjI,KAAAiB,OAAAoG,KACAR,EAAA7G,KAAA6G,QAEAc,GAAA,uBACA3F,EAAA,EAkCA,OAhCAiG,KACAA,EAAA1F,QAAA,SAAAtC,GACA,0BAAAA,GAAA,YAAAW,EAAAX,IACA,cACA0H,EAAA3B,KAAA,aAAA/F,EACA,MAEA,cACA0H,EAAA3B,KAAA,aAAA/F,EACA,MAEA,cACA0H,EAAA3B,KAAA,cAAA/F,EAAA,IACA,MAEA,cACA,OAAAA,EACA0H,EAAA3B,KAAA,kBAEA2B,EAAA3B,KAAA,IAAA9D,KAAAC,UAAAlC,GAAA,8BAEA,MAEA,SACA,SAAAG,OAAA,8CAKA4B,GAAA,mCAAA6E,EAAA,gCAAAc,EAAAjC,KAAA,gMAGA1D,KAgBA1C,IAAA,QACAW,MAAA,QAAAqH,KACA,GAAAA,GAAAtH,KAAAiB,OAAAqG,MACAT,EAAA7G,KAAA6G,QAEA7E,EAAA,EAaA,OAXAW,OAAAC,QAAA0E,KACAtF,GAAA,iHAEAsF,EAAA/E,QAAA,SAAAC,GACA,GAAAuE,GAAA,GAAA1I,GAAAmE,GAAoDqE,WACpD7E,IAAA,4DAAA+E,EAAArE,UAAA,6GAGAV,GAAA,2JAGAA,KAgBA1C,IAAA,QACAW,MAAA,QAAAsH,KACA,GAAAA,GAAAvH,KAAAiB,OAAAsG,MACAV,EAAA7G,KAAA6G,QAEA7E,EAAA,EASA,OAPAW,OAAAC,QAAA2E,IACAA,EAAAhF,QAAA,SAAAC,GACA,GAAAuE,GAAA,GAAA1I,GAAAmE,GAAoDqE,WACpD7E,IAAA,aAAA+E,EAAArE,UAAA,eAIAV,KAgBA1C,IAAA,QACAW,MAAA,QAAAwH,KACA,GAAAA,GAAAzH,KAAAiB,OAAAwG,MACAZ,EAAA7G,KAAA6G,QAEA7E,EAAA,EAaA,OAXAW,OAAAC,QAAA6E,KACAzF,GAAA,sCAAA6E,EAAA,oIAEAY,EAAAlF,QAAA,SAAAC,GACA,GAAAuE,GAAA,GAAA1I,GAAAmE,GAAoDqE,WACpD7E,IAAA,4DAAA+E,EAAArE,UAAA,+GAGAV,GAAA,mWAGAA,KAeA1C,IAAA,MACAW,MAAA,QAAAuH,KACA,GAAAA,GAAAxH,KAAAiB,OAAAuG,IACAX,EAAA7G,KAAA6G,QAEA7E,EAAA,EAEA,mCAAAwF,GAAA,YAAA5G,EAAA4G,KAAA,OAAAA,IAAA7E,MAAAC,QAAA4E,GAAA,CACA,GAAAhF,GAAAgF,EACAT,EAAA,GAAA1I,GAAAmE,GAAkDqE,WAElD7E,IAAA,6PAAgG+E,EAAArE,UAAA,ieAGhG,MAAAV,MAgBA1C,IAAA,aACAW,MAAA,QAAAyB,KACA,GAAAT,GAAAjB,KAAAiB,OACA4F,EAAA7G,KAAA6G,QACAnF,EAAAT,EAAAS,WACAsF,EAAA/F,EAAA+F,SAEAhF,EAAAhC,KAAAgG,MA0BA,OAvBAgB,GAAArE,MAAAC,QAAAoE,QAEA,+BAAAtF,GAAA,YAAAd,EAAAc,KACAtC,OAAAkD,KAAAZ,GAAAa,QAAA,SAAAjD,GACA,GAAAkD,GAAAd,EAAApC,GACA4I,EAAAlB,EAAA3C,QAAA/E,MAAA,EAIAiF,GAAAsC,EAAAvH,GAAAyI,OAAA,SAAAI,GACA,QAAAA,IACWzC,KAAA,KACX0C,EAAA,GAAA/J,GAAAmE,GAAqDqE,QAAAtC,EAAAuC,QAAAoB,GAGrDlG,IAAA,gCAAA1C,EAAA,eAEA0C,GAAAoG,EAAA1F,YAIAV,GAAAhC,KAAAqI,SAmBA/I,IAAA,kBACAW,MAAA,WACA,2EAAAD,KAAAgG,OAAA,8GAAyIhG,KAAAsI,qBAAA,aAAAtI,KAAAuI,wBAAA,sBAA6JvI,KAAAqI,MAAA,YActS/I,IAAA,qBACAW,MAAA,WACA,GAAAuI,GAAAxI,KAAAiB,OAAAuH,kBAEAxG,EAAA,EAUA,OARA,+BAAAwG,GAAA,YAAA5H,EAAA4H,KACApJ,OAAAkD,KAAAkG,GAAAjG,QAAA,SAAApC,GACA,GAAAqC,GAAAgG,EAAArI,GACA4G,EAAA,GAAA1I,GAAAmE,EACAR,IAAA,8BAAA7B,EAAA,kDAAqE4G,EAAArE,UAAA,4BAIrEV,KAeA1C,IAAA,wBACAW,MAAA,WACA,GAAAwI,GAAAzI,KAAAiB,OACAS,EAAA+G,EAAA/G,WACAU,EAAAqG,EAAArG,qBACAyE,EAAA7G,KAAA6G,QAGA7E,EAAA,GAGA2F,GAAA,mBAQA,IALAvI,OAAAkD,KAAAZ,OAAkCa,QAAA,SAAAjD,GAClCqI,EAAA3B,KAAA,YAAA1G,EAAA,OAIA,+BAAA8C,GAAA,YAAAxB,EAAAwB,IAAA,CACA,GAAAI,GAAAJ,EACA2E,EAAA,GAAA1I,GAAAmE,GAAkDqE,UAAA,WAClD7E,IAAA,4DAAA2F,EAAAjC,KAAA,0BAA6GqB,EAAArE,UAAA,sBAQ7G,MAJAN,MAAA,IACAJ,GAAA,4EAAA2F,EAAAjC,KAAA,yMAGA1D,KAeA1C,IAAA,oBACAW,MAAA,WACA,GAAA+B,GAAA,EAOA,OALAhC,MAAA0I,wBACA1I,KAAA0I,uBAAA,EACA1G,GAAAhC,KAAA2I,mBAGA3G,KAeA1C,IAAA,uBACAW,MAAA,WACA,GAAA+B,GAAA,EAOA,OALAhC,MAAA0I,wBACA1I,KAAA0I,uBAAA,EACA1G,GAAAhC,KAAA2I,mBAGA3G,KAeA1C,IAAA,gBACAW,MAAA,QAAA2I,KACA,GAAAA,GAAA5I,KAAAiB,OAAA2H,cACA/B,EAAA7G,KAAA6G,OAGA,uBAAAA,EAAA,4DAAA+B,EAAA,4KAeAtJ,IAAA,gBACAW,MAAA,QAAA4I,KACA,GAAAA,GAAA7I,KAAAiB,OAAA4H,cACAhC,EAAA7G,KAAA6G,OAGA,uBAAAA,EAAA,4DAAAgC,EAAA,6KAuBAvJ,IAAA,eACAW,MAAA,QAAA6I,KACA,GAAAA,GAAA9I,KAAAiB,OAAA6H,aACAjC,EAAA7G,KAAA6G,QAGA7E,EAAAhC,KAAAgG,MAwBA,OAtBA,+BAAA8C,GAAA,YAAAlI,EAAAkI,KACA1J,OAAAkD,KAAAwG,GAAAvG,QAAA,SAAAjD,GACA,GAAAyJ,GAAAD,EAAAxJ,GACAqI,IAEA,IAAAhF,MAAAC,QAAAmG,GACAA,EAAAxG,QAAA,SAAAV,GACA8F,EAAA3B,KAAA,cAAAnE,EAAA,sBAGAG,GAAA,gCAAA1C,EAAA,wBAAAqI,EAAAjC,KAAA,mNACW,mCAAAqD,GAAA,YAAAnI,EAAAmI,IAAA,CACX,GAAAvG,GAAAuG,EACAhC,EAAA,GAAA1I,GAAAmE,GAAsDqE,WAEtD7E,IAAA,gCAAA1C,EAAA,sCAAmFyH,EAAArE,UAAA,iCAKnFV,GAAAhC,KAAAqI,SAiBA/I,IAAA,WACAW,MAAA,WACA,GACA4G,IADA7G,KAAAiB,OAAAS,WACA1B,KAAA6G,SAEA7E,EAAA,EAIA,OAFAA,IAAA,uBAAA6E,EAAA,4LAwBAvH,IAAA,kBACAW,MAAA,QAAAoC,KACA,GAAA2G,GAAAhJ,KAAAiB,OACAU,EAAAqH,EAAArH,MACAU,EAAA2G,EAAA3G,gBAGAL,GAFAhC,KAAA6G,QAEA,GAMA,IAJAxE,KAAA,GAAAM,MAAAC,QAAAjB,KACAK,GAAA,yEAAAL,EAAA5C,OAAA,wLAGA,+BAAAsD,GAAA,YAAAzB,EAAAyB,KAAA,OAAAA,GAAAM,MAAAC,QAAAjB,GAAA,CACA,GAAAa,GAAAH,EACA0E,EAAA,GAAA1I,GAAAmE,GACAyG,EAAA5K,EAAA4K,OAEAjH,IAAA,0CAAAhC,KAAAgG,OAAA,yBAAAiD,EAAA,MAAAtH,EAAA5C,OAAA,MAAyIkK,EAAA,0BAAsCA,EAAA,uCAAsBA,EAAA,gBAAAlC,EAAArE,UAAA,0BAAiG1C,KAAAqI,MAAA,WAGtS,MAAArG,MAmCA1C,IAAA,QACAW,MAAA,QAAA0B,KACA,GAAAA,GAAA3B,KAAAiB,OAAAU,MACAkF,EAAA7G,KAAA6G,QAEA7E,EAAA,EAGA,IAAAW,MAAAC,QAAAjB,GACAK,GAAAhC,KAAAgG,OAEArE,EAAAY,QAAA,SAAAV,EAAAE,GACA,GAAAS,GAAAX,EACAkF,EAAA,GAAA1I,GAAAmE,GAAoDqE,UAAA,IAAA9E,EAAA,KAEpDC,IAAA,wBAAAD,EAAA,iCAAAA,EAAA,gBAAAgF,EAAArE,UAAA,eAGAV,GAAAhC,KAAAqI,UAGO,mCAAA1G,GAAA,YAAAf,EAAAe,KAAA,OAAAA,EAAA,CACP,GAAAa,GAAAb,EACAoF,EAAA,GAAA1I,GAAAmE,GACAyG,EAAA5K,EAAA4K,OAEAjH,IAAA,+BAAAhC,KAAAgG,OAAA,yBAAAiD,EAAA,UAA2GA,EAAA,yBAAqCA,EAAA,wEAAsBA,EAAA,gBAAAlC,EAAArE,UAAA,0BAAkI1C,KAAAqI,MAAA,WAGxS,MAAArG,MAeA1C,IAAA,WACAW,MAAA,QAAAiJ,KACA,GAAAA,GAAAlJ,KAAAiB,OAAAiI,SACArC,EAAA7G,KAAA6G,OAGA,uBAAAA,EAAA,0CAAAqC,EAAA,uKAeA5J,IAAA,WACAW,MAAA,QAAAkJ,KACA,GAAAA,GAAAnJ,KAAAiB,OAAAkI,SACAtC,EAAA7G,KAAA6G,OAGA,uBAAAA,EAAA,0CAAAsC,EAAA,wKAmBA7J,IAAA,cACAW,MAAA,QAAAmJ,KACA,GAAAA,GAAApJ,KAAAiB,OAAAmI,YACAvC,EAAA7G,KAAA6G,QAEA7E,EAAA;AAMA,MAJAoH,MAAA,IACApH,GAAA,yBAAA6E,EAAA,8UAGA7E,KAiBA1C,IAAA,YACAW,MAAA,QAAAoJ,KACA,GAAAA,GAAArJ,KAAAiB,OAAAoI,UACAxC,EAAA7G,KAAA6G,OAGA,uBAAAA,EAAA,+DAAAwC,EAAA,+JAiBA/J,IAAA,YACAW,MAAA,QAAAqJ,KACA,GAAAA,GAAAtJ,KAAAiB,OAAAqI,UACAzC,EAAA7G,KAAA6G,OAGA,uBAAAA,EAAA,+DAAAyC,EAAA,8JAeAhK,IAAA,UACAW,MAAA,QAAAE,KACA,GAAAA,GAAAH,KAAAiB,OAAAd,QACA0G,EAAA7G,KAAA6G,OAGA,IAAA1G,EACA,wBAAA0G,EAAA,6DAAA1G,EAAA,wMAoBAb,IAAA,SACAW,MAAA,QAAAK,KACA,GAAAA,GAAAN,KAAAiB,OAAAX,OACAuG,EAAA7G,KAAA6G,QAEA0C,EAAA9I,EAAAF,QAAAD,EAEA,IAAAiJ,EACA,oBAAA1C,EAAA,4CAAA0C,EAAA,kHAAoJjJ,EAAA,6CAoBpJhB,IAAA,UACAW,MAAA,QAAAuJ,KACA,GAAAC,GAAAzJ,KAAAiB,OACAuI,EAAAC,EAAAD,QACAE,EAAAD,EAAAC,iBACA7C,EAAA7G,KAAA6G,QAEA8C,EAAAD,KAAA,UAEA,uBAAA7C,EAAA,wCAAA8C,EAAA,IAAAH,EAAA,6JAmBAlK,IAAA,UACAW,MAAA,QAAA2J,KACA,GAAAC,GAAA7J,KAAAiB,OACA2I,EAAAC,EAAAD,QACAE,EAAAD,EAAAC,iBACAjD,EAAA7G,KAAA6G,QAEA8C,EAAAG,KAAA,UAEA,uBAAAjD,EAAA,wCAAA8C,EAAA,IAAAC,EAAA,6JAeAtK,IAAA,aACAW,MAAA,QAAA8J,KACA,GAAAA,GAAA/J,KAAAiB,OAAA8I,WAEA/H,EAAA,EAEA,oBAAA+H,GAAA,CACA,GAAAhL,GAAAgL,EAAAC,WAAAjL,OACAkL,EAAAlL,EAAAgL,EAAAG,QAAA,GAAAnL,OAAA,EACAoL,EAAAF,EAAA,EAAAG,KAAAD,IAAA,GAAAF,GAAA,EACAI,EAAA,MAGAA,GADAJ,EAAA,EACA,YAAAE,EAAA,OAAAJ,EAAAI,EAAA,SAEA,WAAAJ,EAAA,SAGA/H,GAAA,iBAAAqI,EAAA,0IAAsGN,EAAA,qCAGtG,MAAA/H,OAIA3D,IAQAb,GAAAD,QAAAc","file":"json-document.min.js","sourcesContent":["var JSONDocument =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  Formats: __webpack_require__(2),\n\t  Initializer: __webpack_require__(3),\n\t  JSONDocument: __webpack_require__(4),\n\t  JSONMapping: __webpack_require__(7),\n\t  JSONPatch: __webpack_require__(5),\n\t  JSONPointer: __webpack_require__(6),\n\t  JSONSchema: __webpack_require__(8),\n\t  Validator: __webpack_require__(9)\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * JSON Schema Formats\n\t *\n\t * TODO\n\t * Is there a good way to express these over multiple lines with comments\n\t * for easier debugging and auditing?\n\t */\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\n\tvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\n\tvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n\tvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\n\tvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\n\tvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\t\n\t/**\n\t * Formats\n\t */\n\t\n\tvar Formats = function () {\n\t  function Formats() {\n\t    _classCallCheck(this, Formats);\n\t  }\n\t\n\t  _createClass(Formats, [{\n\t    key: 'register',\n\t\n\t\n\t    /**\n\t     * Register\n\t     *\n\t     * @description\n\t     * Register a new mapping from named format to RegExp instance\n\t     *\n\t     * TODO\n\t     * We can do some extra validation of the RegExp to\n\t     * ensure it's the acceptable subset of RegExps allowed\n\t     * by JSON Schema.\n\t     *\n\t     * @param {string} name\n\t     * @param {RegExp} pattern\n\t     * @returns {RegExp}\n\t     */\n\t    value: function register(name, pattern) {\n\t      // verify name is a string\n\t      if (typeof name !== 'string') {\n\t        throw new Error('Format name must be a string');\n\t      }\n\t\n\t      // cast a string to RegExp\n\t      if (typeof pattern === 'string') {\n\t        pattern = new RegExp(pattern);\n\t      }\n\t\n\t      return this[name] = pattern;\n\t    }\n\t\n\t    /**\n\t     * Resolve\n\t     *\n\t     * @description\n\t     * Given a format name, return the corresponding registered validation. In the\n\t     * event a format is not registered, throw an error.\n\t     *\n\t     * @param {string} name\n\t     * @returns {RegExp}\n\t     */\n\t\n\t  }, {\n\t    key: 'resolve',\n\t    value: function resolve(name) {\n\t      var format = this[name];\n\t\n\t      if (!format) {\n\t        throw new Error('Unknown JSON Schema format.');\n\t      }\n\t\n\t      return format;\n\t    }\n\t\n\t    /**\n\t     * Test\n\t     *\n\t     * @description\n\t     * Test that a value conforms to a format.\n\t     *\n\t     * @param {string} name\n\t     * @param {string} value\n\t     * @returns {Boolean}\n\t     */\n\t\n\t  }, {\n\t    key: 'test',\n\t    value: function test(name, value) {\n\t      var format = this.resolve(name);\n\t      return format.test(value);\n\t    }\n\t  }], [{\n\t    key: 'initialize',\n\t\n\t\n\t    /**\n\t     * Initialize\n\t     *\n\t     * @description\n\t     * Create a new Formats instance and register default formats\n\t     *\n\t     * @returns {Formats}\n\t     */\n\t    value: function initialize() {\n\t      var formats = new Formats();\n\t      formats.register('date-time', DATETIME_REGEXP);\n\t      formats.register('uri', URI_REGEXP);\n\t      formats.register('email', EMAIL_REGEXP);\n\t      formats.register('ipv4', IPV4_REGEXP);\n\t      formats.register('ipv6', IPV6_REGEXP);\n\t      formats.register('hostname', HOSTNAME_REGEXP);\n\t      return formats;\n\t    }\n\t  }]);\n\t\n\t  return Formats;\n\t}();\n\t\n\t/**\n\t * Export\n\t */\n\t\n\t\n\tmodule.exports = Formats.initialize();\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Initializer\n\t */\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Initializer = function () {\n\t\n\t  /**\n\t   * constructor\n\t   */\n\t  function Initializer(schema, options) {\n\t    _classCallCheck(this, Initializer);\n\t\n\t    Object.assign(this, options || {});\n\t    this.root = this.root || this;\n\t\n\t    this.root.depth = this.root.depth || 1;\n\t\n\t    if (this.level > this.root.depth) {\n\t      this.root.depth = this.level;\n\t    }\n\t\n\t    this.level = this.level || 0;\n\t    this.schema = schema;\n\t  }\n\t\n\t  /**\n\t   * compile (static)\n\t   */\n\t\n\t\n\t  _createClass(Initializer, [{\n\t    key: 'compile',\n\t\n\t\n\t    /**\n\t     * compile\n\t     */\n\t    value: function compile() {\n\t      var root = this.root,\n\t          depth = this.depth,\n\t          level = this.level;\n\t\n\t      var declarations = '';\n\t      var body = '';\n\t\n\t      // traverse the schema and generate code\n\t      body += this.default();\n\t      body += this.properties();\n\t      //body += this.additionalProperties()\n\t      body += this.items();\n\t      //body += this.additionalItems()\n\t\n\t\n\t      // value\n\t      body += this.member();\n\t      body += this.item();\n\t\n\t      // after traversing the schema\n\t      // generate the variable declarations\n\t      if (root === this) {\n\t        for (var i = 1; i <= this.root.depth; i++) {\n\t          declarations += this.declaration(i);\n\t        }\n\t\n\t        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n\t      }\n\t\n\t      return body;\n\t    }\n\t\n\t    /**\n\t     * declaration\n\t     */\n\t\n\t  }, {\n\t    key: 'declaration',\n\t    value: function declaration(level) {\n\t      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n\t    }\n\t\n\t    /**\n\t     * default\n\t     */\n\t\n\t  }, {\n\t    key: 'default',\n\t    value: function _default() {\n\t      var schema = this.schema,\n\t          level = this.level,\n\t          key = this.key,\n\t          index = this.index;\n\t      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\t\n\t      var block = '';\n\t\n\t      if (schema.hasOwnProperty('default')) {\n\t\n\t        if (key) {\n\t          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n\t        }\n\t\n\t        if (index) {\n\t          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n\t        }\n\t\n\t        if (level > 1) {\n\t          block += '\\n          count' + level + '++\\n        ';\n\t        }\n\t\n\t        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * member\n\t     */\n\t\n\t  }, {\n\t    key: 'member',\n\t    value: function member() {\n\t      var schema = this.schema,\n\t          root = this.root,\n\t          level = this.level,\n\t          key = this.key;\n\t      var properties = schema.properties,\n\t          additionalProperties = schema.additionalProperties,\n\t          items = schema.items,\n\t          additionalItems = schema.additionalItems;\n\t\n\t      var block = '';\n\t\n\t      // `key` tells us to treat this subschema as an object member vs an array item\n\t      // and the absence of the other values here indicates we are dealing with a\n\t      // primitive value\n\t      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\t\n\t        // first generate the assignment statement\n\t        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\t\n\t        // for nested container objects, add the counter incrementing statement\n\t        if (level > 1) {\n\t          block += '\\n          count' + level + '++\\n        ';\n\t        }\n\t\n\t        // wrap the foregoing in a check for presence on the source\n\t        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * item\n\t     */\n\t\n\t  }, {\n\t    key: 'item',\n\t    value: function item() {\n\t      var schema = this.schema,\n\t          root = this.root,\n\t          level = this.level,\n\t          index = this.index;\n\t      var properties = schema.properties,\n\t          additionalProperties = schema.additionalProperties,\n\t          items = schema.items,\n\t          additionalItems = schema.additionalItems;\n\t\n\t      var block = '';\n\t\n\t      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\t\n\t        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\t\n\t        if (level > 1) {\n\t          block += '\\n          count' + level + '++\\n        ';\n\t        }\n\t\n\t        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * properties\n\t     */\n\t\n\t  }, {\n\t    key: 'properties',\n\t    value: function properties() {\n\t      var schema = this.schema,\n\t          root = this.root,\n\t          level = this.level,\n\t          key = this.key,\n\t          index = this.index;\n\t      var properties = schema.properties;\n\t\n\t      var block = '';\n\t\n\t      if (properties) {\n\t        Object.keys(properties).forEach(function (key) {\n\t          var subschema = properties[key];\n\t          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\t\n\t          block += initializer.compile();\n\t        });\n\t\n\t        // root-level properties boilerplate\n\t        if (root === this) {\n\t          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\t\n\t          // nested properties boilerplate\n\t        } else {\n\t\n\t          if (index) {\n\t            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n\t          }\n\t\n\t          if (key) {\n\t            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n\t          }\n\t        }\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     *\n\t     */\n\t\n\t  }, {\n\t    key: 'additionalProperties',\n\t    value: function additionalProperties() {}\n\t\n\t    /**\n\t     * items\n\t     */\n\t\n\t  }, {\n\t    key: 'items',\n\t    value: function items() {\n\t      var schema = this.schema,\n\t          root = this.root,\n\t          level = this.level,\n\t          key = this.key,\n\t          index = this.index;\n\t      var items = schema.items;\n\t\n\t      var block = '';\n\t\n\t      if (items) {\n\t\n\t        if (Array.isArray(items)) {\n\t          // TODO\n\t          //\n\t          //\n\t          //\n\t          //\n\t          //\n\t          // ...\n\t\n\t        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n\t          var _index = 'i' + (level + 1);\n\t          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\t\n\t          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n\t        }\n\t\n\t        // root-level properties boilerplate\n\t        if (root === this) {\n\t          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\t\n\t          // nested properties boilerplate\n\t        } else {\n\t          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n\t        }\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     *\n\t     */\n\t\n\t  }, {\n\t    key: 'additionalItems',\n\t    value: function additionalItems() {}\n\t  }], [{\n\t    key: 'compile',\n\t    value: function compile(schema) {\n\t      var initializer = new Initializer(schema);\n\t      var block = initializer.compile();\n\t\n\t      //console.log(beautify(block))\n\t      try {\n\t        return new Function('target', 'source', 'options', block);\n\t      } catch (e) {\n\t        console.log(e, e.stack);\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Initializer;\n\t}();\n\t\n\tmodule.exports = Initializer;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Module dependencies\n\t * @ignore\n\t */\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar JSONPatch = __webpack_require__(5);\n\t\n\t/**\n\t * JSONDocument\n\t *\n\t * @class\n\t * JSONDocument is a high level interface that binds together all other features of\n\t * this package and provides the principle method of data modeling.\n\t */\n\t\n\tvar JSONDocument = function () {\n\t  _createClass(JSONDocument, null, [{\n\t    key: 'schema',\n\t\n\t\n\t    /**\n\t     * Schema\n\t     */\n\t    get: function get() {\n\t      throw new Error('Schema must be defined by classes extending JSONDocument');\n\t    }\n\t\n\t    /**\n\t     * Constructor\n\t     *\n\t     * @param {Object} data\n\t     * @param {Object} options\n\t     */\n\t\n\t  }]);\n\t\n\t  function JSONDocument() {\n\t    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t    _classCallCheck(this, JSONDocument);\n\t\n\t    this.initialize(data, options);\n\t  }\n\t\n\t  /**\n\t   * Initialize\n\t   *\n\t   * @param {Object} data\n\t   * @param {Object} options\n\t   */\n\t\n\t\n\t  _createClass(JSONDocument, [{\n\t    key: 'initialize',\n\t    value: function initialize() {\n\t      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t      var schema = this.constructor.schema;\n\t\n\t      schema.initialize(this, data, options);\n\t    }\n\t\n\t    /**\n\t     * Validate\n\t     *\n\t     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n\t     * @returns {Object}\n\t     */\n\t\n\t  }, {\n\t    key: 'validate',\n\t    value: function validate(alternate) {\n\t      var schema = this.constructor.schema;\n\t\n\t      return (alternate || schema).validate(this);\n\t    }\n\t\n\t    /**\n\t     * Patch\n\t     *\n\t     * @param {Array} ops\n\t     */\n\t\n\t  }, {\n\t    key: 'patch',\n\t    value: function patch(ops) {\n\t      var patch = new JSONPatch(ops);\n\t      patch.apply(this);\n\t    }\n\t\n\t    /**\n\t     * Select\n\t     */\n\t\n\t  }, {\n\t    key: 'select',\n\t    value: function select() {}\n\t\n\t    /**\n\t     * Project\n\t     *\n\t     * @description\n\t     * Given a mapping, return an object projected from the current instance.\n\t     *\n\t     * @example\n\t     * let schema = new JSONSchema({\n\t     *   properties: {\n\t     *     foo: { type: 'Array' }\n\t     *   }\n\t     * })\n\t     *\n\t     * let mapping = new JSONMapping({\n\t     *   '/foo/0': '/bar/baz'\n\t     * })\n\t     *\n\t     * class FooTracker extends JSONDocument {\n\t     *   static get schema () { return schema }\n\t     * }\n\t     *\n\t     * let instance = new FooTracker({ foo: ['qux'] })\n\t     * instance.project(mapping)\n\t     * // => { bar: { baz: 'qux' } }\n\t     *\n\t     * @param {JSONMapping} mapping\n\t     * @return {Object}\n\t     */\n\t\n\t  }, {\n\t    key: 'project',\n\t    value: function project(mapping) {\n\t      return mapping.project(this);\n\t    }\n\t\n\t    /**\n\t     * Serialize\n\t     *\n\t     * @param {Object} object\n\t     * @returns {string}\n\t     */\n\t\n\t  }], [{\n\t    key: 'serialize',\n\t    value: function serialize(object) {\n\t      return JSON.stringify(object);\n\t    }\n\t\n\t    /**\n\t     * Deserialize\n\t     *\n\t     * @param {string} data\n\t     * @return {*}\n\t     */\n\t\n\t  }, {\n\t    key: 'deserialize',\n\t    value: function deserialize(data) {\n\t      try {\n\t        return JSON.parse(data);\n\t      } catch (e) {\n\t        throw new Error('Failed to parse JSON');\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return JSONDocument;\n\t}();\n\t\n\t/**\n\t * Export\n\t */\n\t\n\t\n\tmodule.exports = JSONDocument;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Module dependencies\n\t * @ignore\n\t */\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar JSONPointer = __webpack_require__(6);\n\t\n\t/**\n\t * Modes\n\t */\n\tvar THROW = 0;\n\tvar RECOVER = 1;\n\tvar SILENT = 2;\n\t\n\t/**\n\t * Operations list\n\t */\n\tvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\t\n\t/**\n\t * Patch\n\t *\n\t * @class\n\t * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n\t * https://tools.ietf.org/html/rfc6902\n\t */\n\t\n\tvar JSONPatch = function () {\n\t\n\t  /**\n\t   * Constructor\n\t   *\n\t   * @param {Array} ops\n\t   */\n\t  function JSONPatch(ops) {\n\t    _classCallCheck(this, JSONPatch);\n\t\n\t    this.ops = ops || [];\n\t  }\n\t\n\t  /**\n\t   * Apply\n\t   *\n\t   * @todo handle errors/roll back\n\t   * @todo protect properties that are private in the schema\n\t   * @todo map JSON Pointers real property names\n\t   *\n\t   * @param {Object} target\n\t   */\n\t\n\t\n\t  _createClass(JSONPatch, [{\n\t    key: 'apply',\n\t    value: function apply(target) {\n\t      var _this = this;\n\t\n\t      this.ops.forEach(function (operation) {\n\t        var op = operation.op;\n\t\n\t        if (!op) {\n\t          throw new Error('Missing \"op\" in JSON Patch operation');\n\t        }\n\t\n\t        if (OPERATIONS.indexOf(op) === -1) {\n\t          throw new Error('Invalid \"op\" in JSON Patch operation');\n\t        }\n\t\n\t        if (!operation.path) {\n\t          throw new Error('Missing \"path\" in JSON Patch operation');\n\t        }\n\t\n\t        _this[op](operation, target);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Add\n\t     *\n\t     * @param {Object} op\n\t     * @param {Object} target\n\t     */\n\t\n\t  }, {\n\t    key: 'add',\n\t    value: function add(op, target) {\n\t      if (op.value === undefined) {\n\t        throw new Error('Missing \"value\" in JSON Patch add operation');\n\t      }\n\t\n\t      var pointer = new JSONPointer(op.path, SILENT);\n\t      pointer.add(target, op.value);\n\t    }\n\t\n\t    /**\n\t     * Remove\n\t     *\n\t     * @param {Object} op\n\t     * @param {Object} target\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(op, target) {\n\t      var pointer = new JSONPointer(op.path);\n\t      pointer.remove(target);\n\t    }\n\t\n\t    /**\n\t     * Replace\n\t     *\n\t     * @param {Object} op\n\t     * @param {Object} target\n\t     */\n\t\n\t  }, {\n\t    key: 'replace',\n\t    value: function replace(op, target) {\n\t      if (op.value === undefined) {\n\t        throw new Error('Missing \"value\" in JSON Patch replace operation');\n\t      }\n\t\n\t      var pointer = new JSONPointer(op.path);\n\t      pointer.replace(target, op.value);\n\t    }\n\t\n\t    /**\n\t     * Move\n\t     *\n\t     * @param {Object} op\n\t     * @param {Object} target\n\t     */\n\t\n\t  }, {\n\t    key: 'move',\n\t    value: function move(op, target) {\n\t      if (op.from === undefined) {\n\t        throw new Error('Missing \"from\" in JSON Patch move operation');\n\t      }\n\t\n\t      if (op.path.match(new RegExp('^' + op.from))) {\n\t        throw new Error('Invalid \"from\" in JSON Patch move operation');\n\t      }\n\t\n\t      var pointer = new JSONPointer(op.path);\n\t      var from = new JSONPointer(op.from);\n\t      var value = from.get(target);\n\t\n\t      from.remove(target);\n\t      pointer.add(target, value);\n\t    }\n\t\n\t    /**\n\t     * Copy\n\t     *\n\t     * @param {Object} op\n\t     * @param {Object} target\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(op, target) {\n\t      if (op.from === undefined) {\n\t        throw new Error('Missing \"from\" in JSON Patch copy operation');\n\t      }\n\t\n\t      var pointer = new JSONPointer(op.path);\n\t      var from = new JSONPointer(op.from);\n\t      var value = from.get(target);\n\t\n\t      pointer.add(target, value);\n\t    }\n\t\n\t    /**\n\t     * Test\n\t     *\n\t     * @param {Object} op\n\t     * @param {Object} target\n\t     */\n\t\n\t  }, {\n\t    key: 'test',\n\t    value: function test(op, target) {\n\t      if (op.value === undefined) {\n\t        throw new Error('Missing \"value\" in JSON Patch test operation');\n\t      }\n\t\n\t      var pointer = new JSONPointer(op.path);\n\t      var value = pointer.get(target);\n\t\n\t      switch (_typeof(op.value)) {\n\t        //case 'string':\n\t        //case 'number':\n\t        //case 'boolean':\n\t        //  if (value !== op.value) {\n\t        //    throw new Error('Mismatching JSON Patch test value')\n\t        //  }\n\t        default:\n\t          if (value !== op.value) {\n\t            throw new Error('Mismatching JSON Patch test value');\n\t          }\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return JSONPatch;\n\t}();\n\t\n\t/**\n\t * Exports\n\t */\n\t\n\t\n\tmodule.exports = JSONPatch;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Mode enumeration\n\t */\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar THROW = 0;\n\tvar RECOVER = 1;\n\tvar SILENT = 2;\n\t\n\t/**\n\t * JSONPointer\n\t *\n\t * @class\n\t * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n\t * https://tools.ietf.org/html/rfc6901\n\t */\n\t\n\tvar JSONPointer = function () {\n\t\n\t  /**\n\t   * Constructor\n\t   */\n\t  function JSONPointer(expr, mode) {\n\t    _classCallCheck(this, JSONPointer);\n\t\n\t    this.expr = expr;\n\t    this.mode = mode || THROW;\n\t    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n\t  }\n\t\n\t  /**\n\t   * Escape\n\t   */\n\t\n\t\n\t  _createClass(JSONPointer, [{\n\t    key: 'escape',\n\t    value: function escape(expr) {\n\t      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n\t    }\n\t\n\t    /**\n\t     * Unescape\n\t     */\n\t\n\t  }, {\n\t    key: 'unescape',\n\t    value: function unescape(expr) {\n\t      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n\t    }\n\t\n\t    /**\n\t     * Parse\n\t     */\n\t\n\t  }, {\n\t    key: 'parseJSONString',\n\t\n\t\n\t    /**\n\t     * Parse JSON String\n\t     *\n\t     * @description Parse an expression into a list of tokens\n\t     * @param {string} expr\n\t     * @returns {Array}\n\t     */\n\t    value: function parseJSONString(expr) {\n\t      if (typeof expr !== 'string') {\n\t        throw new Error('JSON Pointer must be a string');\n\t      }\n\t\n\t      if (expr === '') {\n\t        return [];\n\t      }\n\t\n\t      if (expr.charAt(0) !== '/') {\n\t        throw new Error('Invalid JSON Pointer');\n\t      }\n\t\n\t      if (expr === '/') {\n\t        return [''];\n\t      }\n\t\n\t      return expr.substr(1).split('/').map(this.unescape);\n\t    }\n\t\n\t    /**\n\t     * To JSON String\n\t     *\n\t     * @description Render a JSON string representation of a pointer\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'toJSONString',\n\t    value: function toJSONString() {\n\t      return '/' + this.tokens.map(this.escape).join('/');\n\t    }\n\t\n\t    /**\n\t     * Parse URI Fragment Identifer\n\t     */\n\t\n\t  }, {\n\t    key: 'parseURIFragmentIdentifier',\n\t    value: function parseURIFragmentIdentifier(expr) {\n\t      if (typeof expr !== 'string') {\n\t        throw new Error('JSON Pointer must be a string');\n\t      }\n\t\n\t      if (expr.charAt(0) !== '#') {\n\t        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n\t      }\n\t\n\t      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n\t    }\n\t\n\t    /**\n\t     * To URI Fragment Identifier\n\t     *\n\t     * @description Render a URI Fragment Identifier representation of a pointer\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'toURIFragmentIdentifier',\n\t    value: function toURIFragmentIdentifier() {\n\t      var _this = this;\n\t\n\t      var value = this.tokens.map(function (token) {\n\t        return encodeURIComponent(_this.escape(token));\n\t      }).join('/');\n\t\n\t      return '#/' + value;\n\t    }\n\t\n\t    /**\n\t     * Get\n\t     *\n\t     * @description Get a value from the source object referenced by the pointer\n\t     * @param {Object} source\n\t     * @returns {*}\n\t     */\n\t\n\t  }, {\n\t    key: 'get',\n\t    value: function get(source) {\n\t      var current = source;\n\t      var tokens = this.tokens;\n\t\n\t      for (var i = 0; i < tokens.length; i++) {\n\t        if (!current || current[tokens[i]] === undefined) {\n\t          if (this.mode !== THROW) {\n\t            return undefined;\n\t          } else {\n\t            throw new Error('Invalid JSON Pointer reference');\n\t          }\n\t        }\n\t\n\t        current = current[tokens[i]];\n\t      }\n\t\n\t      return current;\n\t    }\n\t\n\t    /**\n\t     * Add\n\t     *\n\t     * @description Set a value on a target object referenced by the pointer. Put\n\t     * will insert an array element. To change an existing array elemnent, use\n\t     * `pointer.set()`\n\t     * @param {Object} target\n\t     * @param {*} value\n\t     */\n\t\n\t  }, {\n\t    key: 'add',\n\t    value: function add(target, value) {\n\t      var tokens = this.tokens;\n\t      var current = target;\n\t\n\t      // iterate through the tokens\n\t      for (var i = 0; i < tokens.length; i++) {\n\t        var token = tokens[i];\n\t\n\t        // set the property on the target location\n\t        if (i === tokens.length - 1) {\n\t          if (token === '-') {\n\t            current.push(value);\n\t          } else if (Array.isArray(current)) {\n\t            current.splice(token, 0, value);\n\t          } else if (value !== undefined) {\n\t            current[token] = value;\n\t          }\n\t\n\t          // handle missing target location based on \"mode\"\n\t        } else if (!current[token]) {\n\t          switch (this.mode) {\n\t            case THROW:\n\t              throw new Error('Invalid JSON Pointer reference');\n\t\n\t            case RECOVER:\n\t              current = current[token] = parseInt(token) ? [] : {};\n\t              break;\n\t\n\t            case SILENT:\n\t              return;\n\t\n\t            default:\n\t              throw new Error('Invalid pointer mode');\n\t          }\n\t\n\t          // reference the next object in the path\n\t        } else {\n\t          current = current[token];\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Replace\n\t     *\n\t     * @description Set a value on a target object referenced by the pointer. Set will\n\t     * overwrite an existing array element at the target location.\n\t     * @param {Object} target\n\t     * @param {*} value\n\t     */\n\t\n\t  }, {\n\t    key: 'replace',\n\t    value: function replace(target, value) {\n\t      var tokens = this.tokens;\n\t      var current = target;\n\t\n\t      for (var i = 0; i < tokens.length; i++) {\n\t        var token = tokens[i];\n\t\n\t        if (i === tokens.length - 1) {\n\t          current[token] = value;\n\t        } else if (!current[token]) {\n\t          current = current[token] = parseInt(token) ? [] : {};\n\t        } else {\n\t          current = current[token];\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Del\n\t     *\n\t     * - if this is an array it should splice the value out\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(target) {\n\t      var tokens = this.tokens;\n\t      var current = target;\n\t\n\t      for (var i = 0; i < tokens.length; i++) {\n\t        var token = tokens[i];\n\t\n\t        if (current === undefined || current[token] === undefined) {\n\t          return undefined;\n\t        } else if (Array.isArray(current)) {\n\t          current.splice(token, 1);\n\t          return undefined;\n\t        } else if (i === tokens.length - 1) {\n\t          delete current[token];\n\t        }\n\t\n\t        current = current[token];\n\t      }\n\t\n\t      // delete from the target\n\t    }\n\t  }], [{\n\t    key: 'parse',\n\t    value: function parse(expr) {\n\t      return new JSONPointer(expr);\n\t    }\n\t  }]);\n\t\n\t  return JSONPointer;\n\t}();\n\t\n\t/**\n\t * Exports\n\t */\n\t\n\t\n\tmodule.exports = JSONPointer;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Module dependencies\n\t * @ignore\n\t */\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar JSONPointer = __webpack_require__(6);\n\t\n\t/**\n\t * JSONPointer mode\n\t */\n\tvar RECOVER = 1;\n\t\n\t/**\n\t * JSONMapping\n\t *\n\t * @class\n\t * Defines a means to declaratively translate between object\n\t * representations using JSON Pointer syntax.\n\t */\n\t\n\tvar JSONMapping = function () {\n\t\n\t  /**\n\t   * Constructor\n\t   *\n\t   * @description Translate pointers from JSON Strings into Pointer objects\n\t   * @param {Object} mapping\n\t   */\n\t  function JSONMapping(mapping) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, JSONMapping);\n\t\n\t    Object.defineProperty(this, 'mapping', {\n\t      enumerable: false,\n\t      value: new Map()\n\t    });\n\t\n\t    Object.keys(mapping).forEach(function (key) {\n\t      var value = mapping[key];\n\t      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Map\n\t   *\n\t   * @description Assign values from source to target by reading the mapping\n\t   * from right to left.\n\t   * @param {Object} target\n\t   * @param {Object} source\n\t   */\n\t\n\t\n\t  _createClass(JSONMapping, [{\n\t    key: 'map',\n\t    value: function map(target, source) {\n\t      this.mapping.forEach(function (right, left) {\n\t        left.add(target, right.get(source));\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Project\n\t     *\n\t     * @description Assign values from source to target by reading the mapping\n\t     * from left to right.\n\t     * @param {Object} source\n\t     * @param {Object} target\n\t     */\n\t\n\t  }, {\n\t    key: 'project',\n\t    value: function project(source, target) {\n\t      this.mapping.forEach(function (right, left) {\n\t        right.add(target, left.get(source));\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return JSONMapping;\n\t}();\n\t\n\t/**\n\t * Exports\n\t */\n\t\n\t\n\tmodule.exports = JSONMapping;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Module dependencies\n\t * @ignore\n\t */\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Initializer = __webpack_require__(3);\n\tvar Validator = __webpack_require__(9);\n\t\n\t/**\n\t * JSONSchema\n\t *\n\t * @class\n\t * Compiles JSON Schema documents to an object with object initialization\n\t * and validation methods.\n\t */\n\t\n\tvar JSONSchema = function () {\n\t\n\t  /**\n\t   * Constructor\n\t   *\n\t   * @param {Object} schema\n\t   */\n\t  function JSONSchema(schema) {\n\t    _classCallCheck(this, JSONSchema);\n\t\n\t    // TODO: optionally parse JSON string?\n\t    Object.assign(this, schema);\n\t\n\t    // add schema-derived initialize and validate methods\n\t    Object.defineProperties(this, {\n\t      initialize: {\n\t        enumerable: false,\n\t        writeable: false,\n\t        value: Initializer.compile(schema)\n\t      },\n\t      validate: {\n\t        enumerable: false,\n\t        writeable: false,\n\t        value: Validator.compile(schema)\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Extend\n\t   *\n\t   * @description\n\t   * ...\n\t   * Dear future,\n\t   *\n\t   * This function was meticulously plagiarized from some curious amalgam of\n\t   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n\t   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n\t   *\n\t   * Goodnight.\n\t   *\n\t   * @param {Object} schema\n\t   * @returns {JSONSchema}\n\t   */\n\t\n\t\n\t  _createClass(JSONSchema, [{\n\t    key: 'extend',\n\t    value: function extend(schema) {\n\t      function isObject(data) {\n\t        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n\t      }\n\t\n\t      function extender(target, source) {\n\t        var result = Object.assign({}, target);\n\t        if (isObject(target) && isObject(source)) {\n\t          Object.keys(source).forEach(function (key) {\n\t            if (isObject(source[key])) {\n\t              if (!(key in target)) {\n\t                Object.assign(result, _defineProperty({}, key, source[key]));\n\t              } else {\n\t                result[key] = extender(target[key], source[key]);\n\t              }\n\t            } else {\n\t              Object.assign(result, _defineProperty({}, key, source[key]));\n\t            }\n\t          });\n\t        }\n\t        return result;\n\t      }\n\t\n\t      var descriptor = extender(this, schema);\n\t      return new JSONSchema(descriptor);\n\t    }\n\t  }]);\n\t\n\t  return JSONSchema;\n\t}();\n\t\n\t/**\n\t * Export\n\t */\n\t\n\t\n\tmodule.exports = JSONSchema;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Module dependencies\n\t * @ignore\n\t */\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar formats = __webpack_require__(2);\n\t\n\t/**\n\t * For variable iterator counter\n\t *\n\t * @type {number}\n\t */\n\tvar indexCount = 0;\n\t\n\t/**\n\t * Validator\n\t *\n\t * Compile an object describing a JSON Schema into a validation function.\n\t */\n\t\n\tvar Validator = function () {\n\t  _createClass(Validator, null, [{\n\t    key: 'compile',\n\t\n\t\n\t    /**\n\t     * Compile (static)\n\t     *\n\t     * @description\n\t     * Compile an object describing a JSON Schema into a validation function.\n\t     *\n\t     * @param {Object} schema\n\t     * @returns {Function}\n\t     */\n\t    value: function compile(schema) {\n\t      var validator = new Validator(schema);\n\t\n\t      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\t\n\t      return new Function('data', body);\n\t    }\n\t\n\t    /**\n\t     * Return current iterator index counter and increase value\n\t     *\n\t     * @returns {number}\n\t     */\n\t\n\t  }, {\n\t    key: 'counter',\n\t    get: function get() {\n\t      return indexCount++;\n\t    }\n\t\n\t    /**\n\t     * Constructor\n\t     *\n\t     * @param {Object} schema - object representation of a schema\n\t     * @param {string} options - compilation options\n\t     */\n\t\n\t  }]);\n\t\n\t  function Validator(schema) {\n\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t    _classCallCheck(this, Validator);\n\t\n\t    // assign schema to this\n\t    this.schema = schema;\n\t\n\t    // assign all options to this\n\t    Object.assign(this, options);\n\t\n\t    // ensure address is defined\n\t    if (!this.address) {\n\t      this.address = '';\n\t    }\n\t\n\t    // ensure require is boolean\n\t    if (this.require !== true) {\n\t      this.require = false;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Compile\n\t   *\n\t   * @description\n\t   * The instance compile method is \"dumb\". It only sequences invocation of\n\t   * more specific compilation methods. It generates code to\n\t   *\n\t   *  - read a value from input\n\t   *  - validate type(s) of input\n\t   *  - validate constraints described by various schema keywords\n\t   *\n\t   * Conditional logic related to code generation is pushed downsteam to\n\t   * type-specific methods.\n\t   */\n\t\n\t\n\t  _createClass(Validator, [{\n\t    key: 'compile',\n\t    value: function compile() {\n\t      var block = '';\n\t\n\t      if (this.require) {\n\t        block += this.required();\n\t      }\n\t\n\t      // type validation\n\t      block += this.type();\n\t\n\t      // type specific validation generators\n\t      // null and boolean are covered by this.type()\n\t      // integer should be covered by number and this.type()\n\t      block += this.array();\n\t      block += this.number();\n\t      block += this.object();\n\t      block += this.string();\n\t\n\t      // non-type-specific validation generators\n\t      block += this.enum();\n\t      block += this.anyOf();\n\t      block += this.allOf();\n\t      block += this.not();\n\t      block += this.oneOf();\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * push\n\t     */\n\t\n\t  }, {\n\t    key: 'push',\n\t    value: function push() {\n\t      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n\t    }\n\t\n\t    /**\n\t     * pop\n\t     */\n\t\n\t  }, {\n\t    key: 'pop',\n\t    value: function pop() {\n\t      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n\t    }\n\t\n\t    /**\n\t     * type\n\t     *\n\t     * @description\n\t     * > An instance matches successfully if its primitive type is one of the\n\t     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n\t     * > JSON Schema Validation Section 5.5.2\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'type',\n\t    value: function type() {\n\t      var type = this.schema.type,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      if (type) {\n\t        var types = Array.isArray(type) ? type : [type];\n\t        var conditions = types.map(function (type) {\n\t          // TODO: can we make a mapping object for this to clean it up?\n\t          if (type === 'array') return '!Array.isArray(value)';\n\t          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n\t          if (type === 'integer') return '!Number.isInteger(value)';\n\t          if (type === 'null') return 'value !== null';\n\t          if (type === 'number') return 'typeof value !== \\'number\\'';\n\t          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n\t          if (type === 'string') return 'typeof value !== \\'string\\'';\n\t        }).join(' && ');\n\t\n\t        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * Type-specific validations\n\t     *\n\t     * Type checking is optional in JSON Schema, and a schema can allow\n\t     * multiple types. Generated code needs to apply type-specific validations\n\t     * only to appropriate values, and ignore everything else. Type validation\n\t     * itself is handled separately from other validation keywords.\n\t     *\n\t     * The methods `array`, `number`, `object`, `string` generate type-specific\n\t     * validation code blocks, wrapped in a conditional such that they will\n\t     * only be applied to values of that type.\n\t     *\n\t     * For example, the `number` method, given the schema\n\t     *\n\t     *     { minimum: 3 }\n\t     *\n\t     * will generate\n\t     *\n\t     *     if (typeof value === 'number') {\n\t     *       if (value < 3) {\n\t     *         valid = false\n\t     *         errors.push({ message: '...' })\n\t     *       }\n\t     *     }\n\t     *\n\t     * Integer values are also numbers, and are validated the same as numbers\n\t     * other than the type validation itself. Therefore no `integer` method is\n\t     * needed.\n\t     */\n\t\n\t    /**\n\t     * array\n\t     *\n\t     * @description\n\t     * Invoke methods for array-specific keywords and wrap resulting code in\n\t     * type-checking conditional so that any resulting validations are only\n\t     * applied to array values.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'array',\n\t    value: function array() {\n\t      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n\t      var validations = this.validations(keywords);\n\t      var block = '';\n\t\n\t      if (validations.length > 0) {\n\t        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * number\n\t     *\n\t     * @description\n\t     * Invoke methods for number-specific keywords and wrap resulting code in\n\t     * type-checking conditional so that any resulting validations are only\n\t     * applied to number values.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'number',\n\t    value: function number() {\n\t      var keywords = ['minimum', 'maximum', 'multipleOf'];\n\t      var validations = this.validations(keywords);\n\t      var block = '';\n\t\n\t      if (validations.length > 0) {\n\t        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * object\n\t     *\n\t     * @description\n\t     * Invoke methods for object-specific keywords and wrap resulting code in\n\t     * type-checking conditional so that any resulting validations are only\n\t     * applied to object values.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'object',\n\t    value: function object() {\n\t      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n\t      var validations = this.validations(keywords);\n\t      var block = '';\n\t\n\t      if (validations.length > 0) {\n\t        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * string\n\t     *\n\t     * @description\n\t     * Invoke methods for string-specific keywords and wrap resulting code in\n\t     * type-checking conditional so that any resulting validations are only\n\t     * applied to string values.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'string',\n\t    value: function string() {\n\t      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n\t      var validations = this.validations(keywords);\n\t      var block = '';\n\t\n\t      if (validations.length > 0) {\n\t        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * validations\n\t     *\n\t     * @description\n\t     * Iterate over an array of keywords and invoke code generator methods\n\t     * for each. Concatenate the results together and return. Used by \"type\"\n\t     * methods such as this.array() and this.string()\n\t     *\n\t     * @param {Array} keywords\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'validations',\n\t    value: function validations(keywords) {\n\t      var _this = this;\n\t\n\t      var schema = this.schema;\n\t\n\t      var block = '';\n\t\n\t      var constraints = Object.keys(schema).filter(function (key) {\n\t        return keywords.indexOf(key) !== -1;\n\t      });\n\t\n\t      constraints.forEach(function (keyword) {\n\t        block += _this[keyword]();\n\t      });\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * enum\n\t     *\n\t     * @description\n\t     * > An instance validates successfully against this keyword if its value\n\t     * > is equal to one of the elements in this keyword's array value.\n\t     * > JSON Schema Validation Section 5.5.1\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'enum',\n\t    value: function _enum() {\n\t      var enumerated = this.schema.enum,\n\t          address = this.address;\n\t\n\t      var conditions = ['value !== undefined'];\n\t      var block = '';\n\t\n\t      if (enumerated) {\n\t        enumerated.forEach(function (value) {\n\t          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n\t            case 'boolean':\n\t              conditions.push('value !== ' + value);\n\t              break;\n\t\n\t            case 'number':\n\t              conditions.push('value !== ' + value);\n\t              break;\n\t\n\t            case 'string':\n\t              conditions.push('value !== \"' + value + '\"');\n\t              break;\n\t\n\t            case 'object':\n\t              if (value === null) {\n\t                conditions.push('value !== null');\n\t              } else {\n\t                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n\t              }\n\t              break;\n\t\n\t            default:\n\t              throw new Error('Things are not well in the land of enum');\n\t\n\t          }\n\t        });\n\t\n\t        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * anyOf\n\t     *\n\t     * @description\n\t     * > An instance validates successfully against this keyword if it\n\t     * > validates successfully against at least one schema defined by this\n\t     * > keyword's value.\n\t     * > JSON Schema Validation Section 5.5.4\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'anyOf',\n\t    value: function anyOf() {\n\t      var anyOf = this.schema.anyOf,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      if (Array.isArray(anyOf)) {\n\t        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\t\n\t        anyOf.forEach(function (subschema) {\n\t          var validator = new Validator(subschema, { address: address });\n\t          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n\t        });\n\t\n\t        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * allOf\n\t     *\n\t     * @description\n\t     * > An instance validates successfully against this keyword if it\n\t     * > validates successfully against all schemas defined by this keyword's\n\t     * > value.\n\t     * > JSON Schema Validation Section 5.5.3\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'allOf',\n\t    value: function allOf() {\n\t      var allOf = this.schema.allOf,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      if (Array.isArray(allOf)) {\n\t        allOf.forEach(function (subschema) {\n\t          var validator = new Validator(subschema, { address: address });\n\t          block += '\\n        ' + validator.compile() + '\\n        ';\n\t        });\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * oneOf\n\t     *\n\t     * @description\n\t     * > An instance validates successfully against this keyword if it\n\t     * > validates successfully against exactly one schema defined by this\n\t     * > keyword's value.\n\t     * > JSON Schema Validation Section 5.5.5\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'oneOf',\n\t    value: function oneOf() {\n\t      var oneOf = this.schema.oneOf,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      if (Array.isArray(oneOf)) {\n\t        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\t\n\t        oneOf.forEach(function (subschema) {\n\t          var validator = new Validator(subschema, { address: address });\n\t          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n\t        });\n\t\n\t        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * not\n\t     *\n\t     * @description\n\t     * > An instance is valid against this keyword if it fails to validate\n\t     * > successfully against the schema defined by this keyword.\n\t     * > JSON Schema Validation Section 5.5.6\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'not',\n\t    value: function not() {\n\t      var not = this.schema.not,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n\t        var subschema = not;\n\t        var validator = new Validator(subschema, { address: address });\n\t\n\t        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * properties\n\t     *\n\t     * @description\n\t     * Iterate over the `properties` schema property if it is an object. For each\n\t     * key, initialize a new Validator for the subschema represented by the property\n\t     * value and invoke compile. Append the result of compiling each subschema to\n\t     * the block of code being generated.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'properties',\n\t    value: function properties() {\n\t      var schema = this.schema,\n\t          address = this.address;\n\t      var properties = schema.properties,\n\t          required = schema.required;\n\t\n\t      var block = this.push();\n\t\n\t      // ensure the value of \"required\" schema property is an array\n\t      required = Array.isArray(required) ? required : [];\n\t\n\t      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n\t        Object.keys(properties).forEach(function (key) {\n\t          var subschema = properties[key];\n\t          var isRequired = required.indexOf(key) !== -1;\n\t          // TODO\n\t          // how should we be calculating these things? should be json pointer?\n\t          // needs a separate function\n\t          var pointer = [address, key].filter(function (segment) {\n\t            return !!segment;\n\t          }).join('.');\n\t          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\t\n\t          // read the value\n\t          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\t\n\t          block += validation.compile();\n\t        });\n\t      }\n\t\n\t      block += this.pop();\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * Other Properties\n\t     *\n\t     * @description\n\t     * This method is not for a keyword. It wraps validations for\n\t     * patternProperties and additionalProperties in a single iteration over\n\t     * an object-type value's properties.\n\t     *\n\t     * It should only be invoked once for a given subschema.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'otherProperties',\n\t    value: function otherProperties() {\n\t      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n\t    }\n\t\n\t    /**\n\t     * Pattern Validations\n\t     *\n\t     * @description\n\t     * Generate validation code from a subschema for properties matching a\n\t     * regular expression.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'patternValidations',\n\t    value: function patternValidations() {\n\t      var patternProperties = this.schema.patternProperties;\n\t\n\t      var block = '';\n\t\n\t      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n\t        Object.keys(patternProperties).forEach(function (pattern) {\n\t          var subschema = patternProperties[pattern];\n\t          var validator = new Validator(subschema);\n\t          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n\t        });\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * Additional Validations\n\t     *\n\t     * @description\n\t     * Generate validation code, either from a subschema for properties not\n\t     * defined in the schema, or to disallow properties not defined in the\n\t     * schema.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'additionalValidations',\n\t    value: function additionalValidations() {\n\t      var _schema = this.schema,\n\t          properties = _schema.properties,\n\t          additionalProperties = _schema.additionalProperties,\n\t          address = this.address;\n\t\n\t      var validations = '';\n\t      var block = '';\n\t\n\t      // catch additional unmatched properties\n\t      var conditions = ['matched !== true'];\n\t\n\t      // ignore defined properties\n\t      Object.keys(properties || {}).forEach(function (key) {\n\t        conditions.push('key !== \\'' + key + '\\'');\n\t      });\n\t\n\t      // validate additional properties\n\t      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n\t        var subschema = additionalProperties;\n\t        var validator = new Validator(subschema, { address: address + '[APKey]' });\n\t        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n\t      }\n\t\n\t      // error for additional properties\n\t      if (additionalProperties === false) {\n\t        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * patternProperties\n\t     *\n\t     * @description\n\t     * Generate validation code for properties matching a pattern\n\t     * defined by the property name (key), which must be a string\n\t     * representing a valid regular expression.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'patternProperties',\n\t    value: function patternProperties() {\n\t      var block = '';\n\t\n\t      if (!this.otherPropertiesCalled) {\n\t        this.otherPropertiesCalled = true;\n\t        block += this.otherProperties();\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * additionalProperties\n\t     *\n\t     * @description\n\t     * Generate validation code for additional properties not defined\n\t     * in the schema, or disallow additional properties if the value of\n\t     * `additionalProperties` in the schema is `false`.\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'additionalProperties',\n\t    value: function additionalProperties() {\n\t      var block = '';\n\t\n\t      if (!this.otherPropertiesCalled) {\n\t        this.otherPropertiesCalled = true;\n\t        block += this.otherProperties();\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * minProperties\n\t     *\n\t     * @description\n\t     * > An object instance is valid against \"minProperties\" if its number of\n\t     * > properties is greater than, or equal to, the value of this keyword.\n\t     * > JSON Schema Validation Section 5.4.2\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'minProperties',\n\t    value: function minProperties() {\n\t      var minProperties = this.schema.minProperties,\n\t          address = this.address;\n\t\n\t\n\t      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n\t    }\n\t\n\t    /**\n\t     * maxProperties\n\t     *\n\t     * @description\n\t     * > An object instance is valid against \"maxProperties\" if its number of\n\t     * > properties is less than, or equal to, the value of this keyword.\n\t     * > JSON Schema Validation Section 5.4.1\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'maxProperties',\n\t    value: function maxProperties() {\n\t      var maxProperties = this.schema.maxProperties,\n\t          address = this.address;\n\t\n\t\n\t      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n\t    }\n\t\n\t    /**\n\t     * Dependencies\n\t     *\n\t     * @description\n\t     * > For all (name, schema) pair of schema dependencies, if the instance has\n\t     * > a property by this name, then it must also validate successfully against\n\t     * > the schema.\n\t     * >\n\t     * > Note that this is the instance itself which must validate successfully,\n\t     * > not the value associated with the property name.\n\t     * >\n\t     * > For each (name, propertyset) pair of property dependencies, if the\n\t     * > instance has a property by this name, then it must also have properties\n\t     * > with the same names as propertyset.\n\t     * > JSON Schema Validation Section 5.4.5.2\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'dependencies',\n\t    value: function dependencies() {\n\t      var dependencies = this.schema.dependencies,\n\t          address = this.address;\n\t\n\t\n\t      var block = this.push();\n\t\n\t      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n\t        Object.keys(dependencies).forEach(function (key) {\n\t          var dependency = dependencies[key];\n\t          var conditions = [];\n\t\n\t          if (Array.isArray(dependency)) {\n\t            dependency.forEach(function (item) {\n\t              conditions.push('container[\\'' + item + '\\'] === undefined');\n\t            });\n\t\n\t            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n\t          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n\t            var subschema = dependency;\n\t            var validator = new Validator(subschema, { address: address });\n\t\n\t            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n\t          }\n\t        });\n\t      }\n\t\n\t      block += this.pop();\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * Required\n\t     *\n\t     * @description\n\t     * > An object instance is valid against this keyword if its property set\n\t     * > contains all elements in this keyword's array value.\n\t     * > JSON Schema Validation Section 5.4.3\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'required',\n\t    value: function required() {\n\t      var properties = this.schema.properties,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * additionalItems\n\t     *\n\t     * @description\n\t     * > Successful validation of an array instance with regards to these two\n\t     * > keywords is determined as follows: if \"items\" is not present, or its\n\t     * > value is an object, validation of the instance always succeeds,\n\t     * > regardless of the value of \"additionalItems\"; if the value of\n\t     * > \"additionalItems\" is boolean value true or an object, validation of\n\t     * > the instance always succeeds; if the value of \"additionalItems\" is\n\t     * > boolean value false and the value of \"items\" is an array, the\n\t     * > instance is valid if its size is less than, or equal to, the size\n\t     * > of \"items\".\n\t     * > JSON Schema Validation Section 5.3.1\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'additionalItems',\n\t    value: function additionalItems() {\n\t      var _schema2 = this.schema,\n\t          items = _schema2.items,\n\t          additionalItems = _schema2.additionalItems,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      if (additionalItems === false && Array.isArray(items)) {\n\t        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n\t      }\n\t\n\t      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n\t        var subschema = additionalItems;\n\t        var validator = new Validator(subschema);\n\t        var counter = Validator.counter;\n\t\n\t        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * Items\n\t     *\n\t     * @description\n\t     * > Successful validation of an array instance with regards to these two\n\t     * > keywords is determined as follows: if \"items\" is not present, or its\n\t     * > value is an object, validation of the instance always succeeds,\n\t     * > regardless of the value of \"additionalItems\"; if the value of\n\t     * > \"additionalItems\" is boolean value true or an object, validation of\n\t     * > the instance always succeeds; if the value of \"additionalItems\" is\n\t     * > boolean value false and the value of \"items\" is an array, the\n\t     * > instance is valid if its size is less than, or equal to, the size\n\t     * > of \"items\".\n\t     * > JSON Schema Validation Section 5.3.1\n\t     *\n\t     * Code to generate\n\t     *\n\t     *     // this outer conditional is generated by this.array()\n\t     *     if (Array.isArray(value) {\n\t     *       let parent = value\n\t     *       for (let i = 0; i < parent.length; i++) {\n\t     *         value = parent[i]\n\t     *         // other validation code depending on value here\n\t     *       }\n\t     *       value = parent\n\t     *     }\n\t     *\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'items',\n\t    value: function items() {\n\t      var items = this.schema.items,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      // if items is an array\n\t      if (Array.isArray(items)) {\n\t        block += this.push();\n\t\n\t        items.forEach(function (item, index) {\n\t          var subschema = item;\n\t          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\t\n\t          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n\t        });\n\t\n\t        block += this.pop();\n\t\n\t        // if items is an object\n\t      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n\t        var subschema = items;\n\t        var validator = new Validator(subschema);\n\t        var counter = Validator.counter;\n\t\n\t        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * minItems\n\t     *\n\t     * @description\n\t     * > An array instance is valid against \"minItems\" if its size is greater\n\t     * > than, or equal to, the value of this keyword.\n\t     * > JSON Schema Validation Section 5.3.3\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'minItems',\n\t    value: function minItems() {\n\t      var minItems = this.schema.minItems,\n\t          address = this.address;\n\t\n\t\n\t      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n\t    }\n\t\n\t    /**\n\t     * maxItems\n\t     *\n\t     * @description\n\t     * > An array instance is valid against \"maxItems\" if its size is less\n\t     * > than, or equal to, the value of this keyword.\n\t     * > JSON Schema Validation Section 5.3.2\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'maxItems',\n\t    value: function maxItems() {\n\t      var maxItems = this.schema.maxItems,\n\t          address = this.address;\n\t\n\t\n\t      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n\t    }\n\t\n\t    /**\n\t     * uniqueItems\n\t     *\n\t     * @description\n\t     * > If this keyword has boolean value false, the instance validates\n\t     * > successfully. If it has boolean value true, the instance validates\n\t     * > successfully if all of its elements are unique.\n\t     * > JSON Schema Validation Section 5.3.4\n\t     *\n\t     * TODO\n\t     * optimize\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'uniqueItems',\n\t    value: function uniqueItems() {\n\t      var uniqueItems = this.schema.uniqueItems,\n\t          address = this.address;\n\t\n\t      var block = '';\n\t\n\t      if (uniqueItems === true) {\n\t        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t\n\t    /**\n\t     * minLength\n\t     *\n\t     * @description\n\t     * > A string instance is valid against this keyword if its length is\n\t     * > greater than, or equal to, the value of this keyword. The length of\n\t     * > a string instance is defined as the number of its characters as\n\t     * > defined by RFC 4627 [RFC4627].\n\t     * > JSON Schema Validation Section 5.2.2\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'minLength',\n\t    value: function minLength() {\n\t      var minLength = this.schema.minLength,\n\t          address = this.address;\n\t\n\t\n\t      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n\t    }\n\t\n\t    /**\n\t     * maxLength\n\t     *\n\t     * @description\n\t     * > A string instance is valid against this keyword if its length is less\n\t     * > than, or equal to, the value of this keyword. The length of a string\n\t     * > instance is defined as the number of its characters as defined by\n\t     * > RFC 4627 [RFC4627].\n\t     * > JSON Schema Validation Section 5.2.1\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'maxLength',\n\t    value: function maxLength() {\n\t      var maxLength = this.schema.maxLength,\n\t          address = this.address;\n\t\n\t\n\t      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n\t    }\n\t\n\t    /**\n\t     * Pattern\n\t     *\n\t     * @description\n\t     * > A string instance is considered valid if the regular expression\n\t     * > matches the instance successfully.\n\t     * > JSON Schema Validation Section 5.2.3\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'pattern',\n\t    value: function pattern() {\n\t      var pattern = this.schema.pattern,\n\t          address = this.address;\n\t\n\t\n\t      if (pattern) {\n\t        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Format\n\t     *\n\t     * @description\n\t     * > Structural validation alone may be insufficient to validate that\n\t     * > an instance meets all the requirements of an application. The\n\t     * > \"format\" keyword is defined to allow interoperable semantic\n\t     * > validation for a fixed subset of values which are accurately\n\t     * > described by authoritative resources, be they RFCs or other\n\t     * > external specifications.\n\t     * > JSON Schema Validation Section 7.1\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'format',\n\t    value: function format() {\n\t      var format = this.schema.format,\n\t          address = this.address;\n\t\n\t      var matcher = formats.resolve(format);\n\t\n\t      if (matcher) {\n\t        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Minimum\n\t     *\n\t     * @description\n\t     * > Successful validation depends on the presence and value of\n\t     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n\t     * > boolean value false, then the instance is valid if it is greater\n\t     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n\t     * > present and has boolean value true, the instance is valid if it is\n\t     * > strictly greater than the value of \"minimum\".\n\t     * > JSON Schema Validation Section 5.1.3\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'minimum',\n\t    value: function minimum() {\n\t      var _schema3 = this.schema,\n\t          minimum = _schema3.minimum,\n\t          exclusiveMinimum = _schema3.exclusiveMinimum,\n\t          address = this.address;\n\t\n\t      var operator = exclusiveMinimum === true ? '<=' : '<';\n\t\n\t      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n\t    }\n\t\n\t    /**\n\t     * Maximum\n\t     *\n\t     * @description\n\t     * > Successful validation depends on the presence and value of\n\t     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n\t     * > boolean value false, then the instance is valid if it is lower than,\n\t     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n\t     * > boolean value true, the instance is valid if it is strictly lower\n\t     * > than the value of \"maximum\".\n\t     * > JSON Schema Validation Section 5.1.2\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'maximum',\n\t    value: function maximum() {\n\t      var _schema4 = this.schema,\n\t          maximum = _schema4.maximum,\n\t          exclusiveMaximum = _schema4.exclusiveMaximum,\n\t          address = this.address;\n\t\n\t      var operator = exclusiveMaximum === true ? '>=' : '>';\n\t\n\t      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n\t    }\n\t\n\t    /**\n\t     * multipleOf\n\t     *\n\t     * @description\n\t     * > A numeric instance is valid against \"multipleOf\" if the result of\n\t     * > the division of the instance by this keyword's value is an integer.\n\t     * > JSON Schema Validation Section 5.1.1\n\t     *\n\t     * @returns {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'multipleOf',\n\t    value: function multipleOf() {\n\t      var multipleOf = this.schema.multipleOf;\n\t\n\t      var block = '';\n\t\n\t      if (typeof multipleOf === 'number') {\n\t        var length = multipleOf.toString().length;\n\t        var decimals = length - multipleOf.toFixed(0).length - 1;\n\t        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n\t        var condition = void 0;\n\t\n\t        if (decimals > 0) {\n\t          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n\t        } else {\n\t          condition = 'value % ' + multipleOf + ' !== 0';\n\t        }\n\t\n\t        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n\t      }\n\t\n\t      return block;\n\t    }\n\t  }]);\n\t\n\t  return Validator;\n\t}();\n\t\n\t/**\n\t * Export\n\t */\n\t\n\t\n\tmodule.exports = Validator;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// json-document.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 60daad43a613fa16cf6e","'use strict';\n\nmodule.exports = {\n  Formats: require('./Formats'),\n  Initializer: require('./Initializer'),\n  JSONDocument: require('./JSONDocument'),\n  JSONMapping: require('./JSONMapping'),\n  JSONPatch: require('./JSONPatch'),\n  JSONPointer: require('./JSONPointer'),\n  JSONSchema: require('./JSONSchema'),\n  Validator: require('./Validator')\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/index.js\n// module id = 1\n// module chunks = 0","'use strict';\n\n/**\n * JSON Schema Formats\n *\n * TODO\n * Is there a good way to express these over multiple lines with comments\n * for easier debugging and auditing?\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\nvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\nvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\nvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\nvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\n/**\n * Formats\n */\n\nvar Formats = function () {\n  function Formats() {\n    _classCallCheck(this, Formats);\n  }\n\n  _createClass(Formats, [{\n    key: 'register',\n\n\n    /**\n     * Register\n     *\n     * @description\n     * Register a new mapping from named format to RegExp instance\n     *\n     * TODO\n     * We can do some extra validation of the RegExp to\n     * ensure it's the acceptable subset of RegExps allowed\n     * by JSON Schema.\n     *\n     * @param {string} name\n     * @param {RegExp} pattern\n     * @returns {RegExp}\n     */\n    value: function register(name, pattern) {\n      // verify name is a string\n      if (typeof name !== 'string') {\n        throw new Error('Format name must be a string');\n      }\n\n      // cast a string to RegExp\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n      }\n\n      return this[name] = pattern;\n    }\n\n    /**\n     * Resolve\n     *\n     * @description\n     * Given a format name, return the corresponding registered validation. In the\n     * event a format is not registered, throw an error.\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(name) {\n      var format = this[name];\n\n      if (!format) {\n        throw new Error('Unknown JSON Schema format.');\n      }\n\n      return format;\n    }\n\n    /**\n     * Test\n     *\n     * @description\n     * Test that a value conforms to a format.\n     *\n     * @param {string} name\n     * @param {string} value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(name, value) {\n      var format = this.resolve(name);\n      return format.test(value);\n    }\n  }], [{\n    key: 'initialize',\n\n\n    /**\n     * Initialize\n     *\n     * @description\n     * Create a new Formats instance and register default formats\n     *\n     * @returns {Formats}\n     */\n    value: function initialize() {\n      var formats = new Formats();\n      formats.register('date-time', DATETIME_REGEXP);\n      formats.register('uri', URI_REGEXP);\n      formats.register('email', EMAIL_REGEXP);\n      formats.register('ipv4', IPV4_REGEXP);\n      formats.register('ipv6', IPV6_REGEXP);\n      formats.register('hostname', HOSTNAME_REGEXP);\n      return formats;\n    }\n  }]);\n\n  return Formats;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Formats.initialize();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Formats.js\n// module id = 2\n// module chunks = 0","'use strict';\n\n/**\n * Initializer\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = function () {\n\n  /**\n   * constructor\n   */\n  function Initializer(schema, options) {\n    _classCallCheck(this, Initializer);\n\n    Object.assign(this, options || {});\n    this.root = this.root || this;\n\n    this.root.depth = this.root.depth || 1;\n\n    if (this.level > this.root.depth) {\n      this.root.depth = this.level;\n    }\n\n    this.level = this.level || 0;\n    this.schema = schema;\n  }\n\n  /**\n   * compile (static)\n   */\n\n\n  _createClass(Initializer, [{\n    key: 'compile',\n\n\n    /**\n     * compile\n     */\n    value: function compile() {\n      var root = this.root,\n          depth = this.depth,\n          level = this.level;\n\n      var declarations = '';\n      var body = '';\n\n      // traverse the schema and generate code\n      body += this.default();\n      body += this.properties();\n      //body += this.additionalProperties()\n      body += this.items();\n      //body += this.additionalItems()\n\n\n      // value\n      body += this.member();\n      body += this.item();\n\n      // after traversing the schema\n      // generate the variable declarations\n      if (root === this) {\n        for (var i = 1; i <= this.root.depth; i++) {\n          declarations += this.declaration(i);\n        }\n\n        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n      }\n\n      return body;\n    }\n\n    /**\n     * declaration\n     */\n\n  }, {\n    key: 'declaration',\n    value: function declaration(level) {\n      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n    }\n\n    /**\n     * default\n     */\n\n  }, {\n    key: 'default',\n    value: function _default() {\n      var schema = this.schema,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\n      var block = '';\n\n      if (schema.hasOwnProperty('default')) {\n\n        if (key) {\n          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (index) {\n          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * member\n     */\n\n  }, {\n    key: 'member',\n    value: function member() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      // `key` tells us to treat this subschema as an object member vs an array item\n      // and the absence of the other values here indicates we are dealing with a\n      // primitive value\n      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\n        // first generate the assignment statement\n        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\n        // for nested container objects, add the counter incrementing statement\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        // wrap the foregoing in a check for presence on the source\n        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * item\n     */\n\n  }, {\n    key: 'item',\n    value: function item() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          index = this.index;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\n        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var properties = schema.properties;\n\n      var block = '';\n\n      if (properties) {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\n          block += initializer.compile();\n        });\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n\n          if (index) {\n            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n          }\n\n          if (key) {\n            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n          }\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {}\n\n    /**\n     * items\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var items = schema.items;\n\n      var block = '';\n\n      if (items) {\n\n        if (Array.isArray(items)) {\n          // TODO\n          //\n          //\n          //\n          //\n          //\n          // ...\n\n        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n          var _index = 'i' + (level + 1);\n          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\n          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n        }\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {}\n  }], [{\n    key: 'compile',\n    value: function compile(schema) {\n      var initializer = new Initializer(schema);\n      var block = initializer.compile();\n\n      //console.log(beautify(block))\n      try {\n        return new Function('target', 'source', 'options', block);\n      } catch (e) {\n        console.log(e, e.stack);\n      }\n    }\n  }]);\n\n  return Initializer;\n}();\n\nmodule.exports = Initializer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Initializer.js\n// module id = 3\n// module chunks = 0","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPatch = require('./JSONPatch');\n\n/**\n * JSONDocument\n *\n * @class\n * JSONDocument is a high level interface that binds together all other features of\n * this package and provides the principle method of data modeling.\n */\n\nvar JSONDocument = function () {\n  _createClass(JSONDocument, null, [{\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      throw new Error('Schema must be defined by classes extending JSONDocument');\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} data\n     * @param {Object} options\n     */\n\n  }]);\n\n  function JSONDocument() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSONDocument);\n\n    this.initialize(data, options);\n  }\n\n  /**\n   * Initialize\n   *\n   * @param {Object} data\n   * @param {Object} options\n   */\n\n\n  _createClass(JSONDocument, [{\n    key: 'initialize',\n    value: function initialize() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = this.constructor.schema;\n\n      schema.initialize(this, data, options);\n    }\n\n    /**\n     * Validate\n     *\n     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(alternate) {\n      var schema = this.constructor.schema;\n\n      return (alternate || schema).validate(this);\n    }\n\n    /**\n     * Patch\n     *\n     * @param {Array} ops\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(ops) {\n      var patch = new JSONPatch(ops);\n      patch.apply(this);\n    }\n\n    /**\n     * Select\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {}\n\n    /**\n     * Project\n     *\n     * @description\n     * Given a mapping, return an object projected from the current instance.\n     *\n     * @example\n     * let schema = new JSONSchema({\n     *   properties: {\n     *     foo: { type: 'Array' }\n     *   }\n     * })\n     *\n     * let mapping = new JSONMapping({\n     *   '/foo/0': '/bar/baz'\n     * })\n     *\n     * class FooTracker extends JSONDocument {\n     *   static get schema () { return schema }\n     * }\n     *\n     * let instance = new FooTracker({ foo: ['qux'] })\n     * instance.project(mapping)\n     * // => { bar: { baz: 'qux' } }\n     *\n     * @param {JSONMapping} mapping\n     * @return {Object}\n     */\n\n  }, {\n    key: 'project',\n    value: function project(mapping) {\n      return mapping.project(this);\n    }\n\n    /**\n     * Serialize\n     *\n     * @param {Object} object\n     * @returns {string}\n     */\n\n  }], [{\n    key: 'serialize',\n    value: function serialize(object) {\n      return JSON.stringify(object);\n    }\n\n    /**\n     * Deserialize\n     *\n     * @param {string} data\n     * @return {*}\n     */\n\n  }, {\n    key: 'deserialize',\n    value: function deserialize(data) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        throw new Error('Failed to parse JSON');\n      }\n    }\n  }]);\n\n  return JSONDocument;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONDocument;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/JSONDocument.js\n// module id = 4\n// module chunks = 0","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = require('./JSONPointer');\n\n/**\n * Modes\n */\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * Operations list\n */\nvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\n/**\n * Patch\n *\n * @class\n * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n * https://tools.ietf.org/html/rfc6902\n */\n\nvar JSONPatch = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Array} ops\n   */\n  function JSONPatch(ops) {\n    _classCallCheck(this, JSONPatch);\n\n    this.ops = ops || [];\n  }\n\n  /**\n   * Apply\n   *\n   * @todo handle errors/roll back\n   * @todo protect properties that are private in the schema\n   * @todo map JSON Pointers real property names\n   *\n   * @param {Object} target\n   */\n\n\n  _createClass(JSONPatch, [{\n    key: 'apply',\n    value: function apply(target) {\n      var _this = this;\n\n      this.ops.forEach(function (operation) {\n        var op = operation.op;\n\n        if (!op) {\n          throw new Error('Missing \"op\" in JSON Patch operation');\n        }\n\n        if (OPERATIONS.indexOf(op) === -1) {\n          throw new Error('Invalid \"op\" in JSON Patch operation');\n        }\n\n        if (!operation.path) {\n          throw new Error('Missing \"path\" in JSON Patch operation');\n        }\n\n        _this[op](operation, target);\n      });\n    }\n\n    /**\n     * Add\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'add',\n    value: function add(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch add operation');\n      }\n\n      var pointer = new JSONPointer(op.path, SILENT);\n      pointer.add(target, op.value);\n    }\n\n    /**\n     * Remove\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(op, target) {\n      var pointer = new JSONPointer(op.path);\n      pointer.remove(target);\n    }\n\n    /**\n     * Replace\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch replace operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      pointer.replace(target, op.value);\n    }\n\n    /**\n     * Move\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'move',\n    value: function move(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch move operation');\n      }\n\n      if (op.path.match(new RegExp('^' + op.from))) {\n        throw new Error('Invalid \"from\" in JSON Patch move operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      from.remove(target);\n      pointer.add(target, value);\n    }\n\n    /**\n     * Copy\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch copy operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      pointer.add(target, value);\n    }\n\n    /**\n     * Test\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'test',\n    value: function test(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch test operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var value = pointer.get(target);\n\n      switch (_typeof(op.value)) {\n        //case 'string':\n        //case 'number':\n        //case 'boolean':\n        //  if (value !== op.value) {\n        //    throw new Error('Mismatching JSON Patch test value')\n        //  }\n        default:\n          if (value !== op.value) {\n            throw new Error('Mismatching JSON Patch test value');\n          }\n      }\n    }\n  }]);\n\n  return JSONPatch;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPatch;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/JSONPatch.js\n// module id = 5\n// module chunks = 0","'use strict';\n\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n\n  /**\n   * Escape\n   */\n\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n\n      return '#/' + value;\n    }\n\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      // iterate through the tokens\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        // set the property on the target location\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          }\n\n          // handle missing target location based on \"mode\"\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          }\n\n          // reference the next object in the path\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      }\n\n      // delete from the target\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPointer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/JSONPointer.js\n// module id = 6\n// module chunks = 0","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = require('./JSONPointer');\n\n/**\n * JSONPointer mode\n */\nvar RECOVER = 1;\n\n/**\n * JSONMapping\n *\n * @class\n * Defines a means to declaratively translate between object\n * representations using JSON Pointer syntax.\n */\n\nvar JSONMapping = function () {\n\n  /**\n   * Constructor\n   *\n   * @description Translate pointers from JSON Strings into Pointer objects\n   * @param {Object} mapping\n   */\n  function JSONMapping(mapping) {\n    var _this = this;\n\n    _classCallCheck(this, JSONMapping);\n\n    Object.defineProperty(this, 'mapping', {\n      enumerable: false,\n      value: new Map()\n    });\n\n    Object.keys(mapping).forEach(function (key) {\n      var value = mapping[key];\n      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n    });\n  }\n\n  /**\n   * Map\n   *\n   * @description Assign values from source to target by reading the mapping\n   * from right to left.\n   * @param {Object} target\n   * @param {Object} source\n   */\n\n\n  _createClass(JSONMapping, [{\n    key: 'map',\n    value: function map(target, source) {\n      this.mapping.forEach(function (right, left) {\n        left.add(target, right.get(source));\n      });\n    }\n\n    /**\n     * Project\n     *\n     * @description Assign values from source to target by reading the mapping\n     * from left to right.\n     * @param {Object} source\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'project',\n    value: function project(source, target) {\n      this.mapping.forEach(function (right, left) {\n        right.add(target, left.get(source));\n      });\n    }\n  }]);\n\n  return JSONMapping;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONMapping;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/JSONMapping.js\n// module id = 7\n// module chunks = 0","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = require('./Initializer');\nvar Validator = require('./Validator');\n\n/**\n * JSONSchema\n *\n * @class\n * Compiles JSON Schema documents to an object with object initialization\n * and validation methods.\n */\n\nvar JSONSchema = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Object} schema\n   */\n  function JSONSchema(schema) {\n    _classCallCheck(this, JSONSchema);\n\n    // TODO: optionally parse JSON string?\n    Object.assign(this, schema);\n\n    // add schema-derived initialize and validate methods\n    Object.defineProperties(this, {\n      initialize: {\n        enumerable: false,\n        writeable: false,\n        value: Initializer.compile(schema)\n      },\n      validate: {\n        enumerable: false,\n        writeable: false,\n        value: Validator.compile(schema)\n      }\n    });\n  }\n\n  /**\n   * Extend\n   *\n   * @description\n   * ...\n   * Dear future,\n   *\n   * This function was meticulously plagiarized from some curious amalgam of\n   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n   *\n   * Goodnight.\n   *\n   * @param {Object} schema\n   * @returns {JSONSchema}\n   */\n\n\n  _createClass(JSONSchema, [{\n    key: 'extend',\n    value: function extend(schema) {\n      function isObject(data) {\n        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n      }\n\n      function extender(target, source) {\n        var result = Object.assign({}, target);\n        if (isObject(target) && isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(result, _defineProperty({}, key, source[key]));\n              } else {\n                result[key] = extender(target[key], source[key]);\n              }\n            } else {\n              Object.assign(result, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n        return result;\n      }\n\n      var descriptor = extender(this, schema);\n      return new JSONSchema(descriptor);\n    }\n  }]);\n\n  return JSONSchema;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONSchema;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/JSONSchema.js\n// module id = 8\n// module chunks = 0","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar formats = require('./Formats');\n\n/**\n * For variable iterator counter\n *\n * @type {number}\n */\nvar indexCount = 0;\n\n/**\n * Validator\n *\n * Compile an object describing a JSON Schema into a validation function.\n */\n\nvar Validator = function () {\n  _createClass(Validator, null, [{\n    key: 'compile',\n\n\n    /**\n     * Compile (static)\n     *\n     * @description\n     * Compile an object describing a JSON Schema into a validation function.\n     *\n     * @param {Object} schema\n     * @returns {Function}\n     */\n    value: function compile(schema) {\n      var validator = new Validator(schema);\n\n      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\n      return new Function('data', body);\n    }\n\n    /**\n     * Return current iterator index counter and increase value\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'counter',\n    get: function get() {\n      return indexCount++;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} schema - object representation of a schema\n     * @param {string} options - compilation options\n     */\n\n  }]);\n\n  function Validator(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Validator);\n\n    // assign schema to this\n    this.schema = schema;\n\n    // assign all options to this\n    Object.assign(this, options);\n\n    // ensure address is defined\n    if (!this.address) {\n      this.address = '';\n    }\n\n    // ensure require is boolean\n    if (this.require !== true) {\n      this.require = false;\n    }\n  }\n\n  /**\n   * Compile\n   *\n   * @description\n   * The instance compile method is \"dumb\". It only sequences invocation of\n   * more specific compilation methods. It generates code to\n   *\n   *  - read a value from input\n   *  - validate type(s) of input\n   *  - validate constraints described by various schema keywords\n   *\n   * Conditional logic related to code generation is pushed downsteam to\n   * type-specific methods.\n   */\n\n\n  _createClass(Validator, [{\n    key: 'compile',\n    value: function compile() {\n      var block = '';\n\n      if (this.require) {\n        block += this.required();\n      }\n\n      // type validation\n      block += this.type();\n\n      // type specific validation generators\n      // null and boolean are covered by this.type()\n      // integer should be covered by number and this.type()\n      block += this.array();\n      block += this.number();\n      block += this.object();\n      block += this.string();\n\n      // non-type-specific validation generators\n      block += this.enum();\n      block += this.anyOf();\n      block += this.allOf();\n      block += this.not();\n      block += this.oneOf();\n\n      return block;\n    }\n\n    /**\n     * push\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n    }\n\n    /**\n     * pop\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n    }\n\n    /**\n     * type\n     *\n     * @description\n     * > An instance matches successfully if its primitive type is one of the\n     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n     * > JSON Schema Validation Section 5.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'type',\n    value: function type() {\n      var type = this.schema.type,\n          address = this.address;\n\n      var block = '';\n\n      if (type) {\n        var types = Array.isArray(type) ? type : [type];\n        var conditions = types.map(function (type) {\n          // TODO: can we make a mapping object for this to clean it up?\n          if (type === 'array') return '!Array.isArray(value)';\n          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n          if (type === 'integer') return '!Number.isInteger(value)';\n          if (type === 'null') return 'value !== null';\n          if (type === 'number') return 'typeof value !== \\'number\\'';\n          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n          if (type === 'string') return 'typeof value !== \\'string\\'';\n        }).join(' && ');\n\n        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Type-specific validations\n     *\n     * Type checking is optional in JSON Schema, and a schema can allow\n     * multiple types. Generated code needs to apply type-specific validations\n     * only to appropriate values, and ignore everything else. Type validation\n     * itself is handled separately from other validation keywords.\n     *\n     * The methods `array`, `number`, `object`, `string` generate type-specific\n     * validation code blocks, wrapped in a conditional such that they will\n     * only be applied to values of that type.\n     *\n     * For example, the `number` method, given the schema\n     *\n     *     { minimum: 3 }\n     *\n     * will generate\n     *\n     *     if (typeof value === 'number') {\n     *       if (value < 3) {\n     *         valid = false\n     *         errors.push({ message: '...' })\n     *       }\n     *     }\n     *\n     * Integer values are also numbers, and are validated the same as numbers\n     * other than the type validation itself. Therefore no `integer` method is\n     * needed.\n     */\n\n    /**\n     * array\n     *\n     * @description\n     * Invoke methods for array-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to array values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'array',\n    value: function array() {\n      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * number\n     *\n     * @description\n     * Invoke methods for number-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to number values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'number',\n    value: function number() {\n      var keywords = ['minimum', 'maximum', 'multipleOf'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * object\n     *\n     * @description\n     * Invoke methods for object-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to object values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'object',\n    value: function object() {\n      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * string\n     *\n     * @description\n     * Invoke methods for string-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to string values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * validations\n     *\n     * @description\n     * Iterate over an array of keywords and invoke code generator methods\n     * for each. Concatenate the results together and return. Used by \"type\"\n     * methods such as this.array() and this.string()\n     *\n     * @param {Array} keywords\n     * @returns {string}\n     */\n\n  }, {\n    key: 'validations',\n    value: function validations(keywords) {\n      var _this = this;\n\n      var schema = this.schema;\n\n      var block = '';\n\n      var constraints = Object.keys(schema).filter(function (key) {\n        return keywords.indexOf(key) !== -1;\n      });\n\n      constraints.forEach(function (keyword) {\n        block += _this[keyword]();\n      });\n\n      return block;\n    }\n\n    /**\n     * enum\n     *\n     * @description\n     * > An instance validates successfully against this keyword if its value\n     * > is equal to one of the elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.5.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'enum',\n    value: function _enum() {\n      var enumerated = this.schema.enum,\n          address = this.address;\n\n      var conditions = ['value !== undefined'];\n      var block = '';\n\n      if (enumerated) {\n        enumerated.forEach(function (value) {\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'number':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'string':\n              conditions.push('value !== \"' + value + '\"');\n              break;\n\n            case 'object':\n              if (value === null) {\n                conditions.push('value !== null');\n              } else {\n                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n              }\n              break;\n\n            default:\n              throw new Error('Things are not well in the land of enum');\n\n          }\n        });\n\n        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * anyOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against at least one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.4\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'anyOf',\n    value: function anyOf() {\n      var anyOf = this.schema.anyOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(anyOf)) {\n        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\n        anyOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n        });\n\n        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * allOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against all schemas defined by this keyword's\n     * > value.\n     * > JSON Schema Validation Section 5.5.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'allOf',\n    value: function allOf() {\n      var allOf = this.schema.allOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(allOf)) {\n        allOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        ' + validator.compile() + '\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * oneOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against exactly one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.5\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      var oneOf = this.schema.oneOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(oneOf)) {\n        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\n        oneOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n        });\n\n        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * not\n     *\n     * @description\n     * > An instance is valid against this keyword if it fails to validate\n     * > successfully against the schema defined by this keyword.\n     * > JSON Schema Validation Section 5.5.6\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'not',\n    value: function not() {\n      var not = this.schema.not,\n          address = this.address;\n\n      var block = '';\n\n      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n        var subschema = not;\n        var validator = new Validator(subschema, { address: address });\n\n        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     *\n     * @description\n     * Iterate over the `properties` schema property if it is an object. For each\n     * key, initialize a new Validator for the subschema represented by the property\n     * value and invoke compile. Append the result of compiling each subschema to\n     * the block of code being generated.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          address = this.address;\n      var properties = schema.properties,\n          required = schema.required;\n\n      var block = this.push();\n\n      // ensure the value of \"required\" schema property is an array\n      required = Array.isArray(required) ? required : [];\n\n      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var isRequired = required.indexOf(key) !== -1;\n          // TODO\n          // how should we be calculating these things? should be json pointer?\n          // needs a separate function\n          var pointer = [address, key].filter(function (segment) {\n            return !!segment;\n          }).join('.');\n          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\n          // read the value\n          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\n          block += validation.compile();\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Other Properties\n     *\n     * @description\n     * This method is not for a keyword. It wraps validations for\n     * patternProperties and additionalProperties in a single iteration over\n     * an object-type value's properties.\n     *\n     * It should only be invoked once for a given subschema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'otherProperties',\n    value: function otherProperties() {\n      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n    }\n\n    /**\n     * Pattern Validations\n     *\n     * @description\n     * Generate validation code from a subschema for properties matching a\n     * regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternValidations',\n    value: function patternValidations() {\n      var patternProperties = this.schema.patternProperties;\n\n      var block = '';\n\n      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n        Object.keys(patternProperties).forEach(function (pattern) {\n          var subschema = patternProperties[pattern];\n          var validator = new Validator(subschema);\n          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * Additional Validations\n     *\n     * @description\n     * Generate validation code, either from a subschema for properties not\n     * defined in the schema, or to disallow properties not defined in the\n     * schema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalValidations',\n    value: function additionalValidations() {\n      var _schema = this.schema,\n          properties = _schema.properties,\n          additionalProperties = _schema.additionalProperties,\n          address = this.address;\n\n      var validations = '';\n      var block = '';\n\n      // catch additional unmatched properties\n      var conditions = ['matched !== true'];\n\n      // ignore defined properties\n      Object.keys(properties || {}).forEach(function (key) {\n        conditions.push('key !== \\'' + key + '\\'');\n      });\n\n      // validate additional properties\n      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n        var subschema = additionalProperties;\n        var validator = new Validator(subschema, { address: address + '[APKey]' });\n        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n      }\n\n      // error for additional properties\n      if (additionalProperties === false) {\n        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * patternProperties\n     *\n     * @description\n     * Generate validation code for properties matching a pattern\n     * defined by the property name (key), which must be a string\n     * representing a valid regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternProperties',\n    value: function patternProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * additionalProperties\n     *\n     * @description\n     * Generate validation code for additional properties not defined\n     * in the schema, or disallow additional properties if the value of\n     * `additionalProperties` in the schema is `false`.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * minProperties\n     *\n     * @description\n     * > An object instance is valid against \"minProperties\" if its number of\n     * > properties is greater than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minProperties',\n    value: function minProperties() {\n      var minProperties = this.schema.minProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxProperties\n     *\n     * @description\n     * > An object instance is valid against \"maxProperties\" if its number of\n     * > properties is less than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxProperties',\n    value: function maxProperties() {\n      var maxProperties = this.schema.maxProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Dependencies\n     *\n     * @description\n     * > For all (name, schema) pair of schema dependencies, if the instance has\n     * > a property by this name, then it must also validate successfully against\n     * > the schema.\n     * >\n     * > Note that this is the instance itself which must validate successfully,\n     * > not the value associated with the property name.\n     * >\n     * > For each (name, propertyset) pair of property dependencies, if the\n     * > instance has a property by this name, then it must also have properties\n     * > with the same names as propertyset.\n     * > JSON Schema Validation Section 5.4.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'dependencies',\n    value: function dependencies() {\n      var dependencies = this.schema.dependencies,\n          address = this.address;\n\n\n      var block = this.push();\n\n      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n        Object.keys(dependencies).forEach(function (key) {\n          var dependency = dependencies[key];\n          var conditions = [];\n\n          if (Array.isArray(dependency)) {\n            dependency.forEach(function (item) {\n              conditions.push('container[\\'' + item + '\\'] === undefined');\n            });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n            var subschema = dependency;\n            var validator = new Validator(subschema, { address: address });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n          }\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Required\n     *\n     * @description\n     * > An object instance is valid against this keyword if its property set\n     * > contains all elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.4.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'required',\n    value: function required() {\n      var properties = this.schema.properties,\n          address = this.address;\n\n      var block = '';\n\n      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\n      return block;\n    }\n\n    /**\n     * additionalItems\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {\n      var _schema2 = this.schema,\n          items = _schema2.items,\n          additionalItems = _schema2.additionalItems,\n          address = this.address;\n\n      var block = '';\n\n      if (additionalItems === false && Array.isArray(items)) {\n        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n      }\n\n      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n        var subschema = additionalItems;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Items\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * Code to generate\n     *\n     *     // this outer conditional is generated by this.array()\n     *     if (Array.isArray(value) {\n     *       let parent = value\n     *       for (let i = 0; i < parent.length; i++) {\n     *         value = parent[i]\n     *         // other validation code depending on value here\n     *       }\n     *       value = parent\n     *     }\n     *\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var items = this.schema.items,\n          address = this.address;\n\n      var block = '';\n\n      // if items is an array\n      if (Array.isArray(items)) {\n        block += this.push();\n\n        items.forEach(function (item, index) {\n          var subschema = item;\n          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\n          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n        });\n\n        block += this.pop();\n\n        // if items is an object\n      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n        var subschema = items;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minItems\n     *\n     * @description\n     * > An array instance is valid against \"minItems\" if its size is greater\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minItems',\n    value: function minItems() {\n      var minItems = this.schema.minItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxItems\n     *\n     * @description\n     * > An array instance is valid against \"maxItems\" if its size is less\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxItems',\n    value: function maxItems() {\n      var maxItems = this.schema.maxItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * uniqueItems\n     *\n     * @description\n     * > If this keyword has boolean value false, the instance validates\n     * > successfully. If it has boolean value true, the instance validates\n     * > successfully if all of its elements are unique.\n     * > JSON Schema Validation Section 5.3.4\n     *\n     * TODO\n     * optimize\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'uniqueItems',\n    value: function uniqueItems() {\n      var uniqueItems = this.schema.uniqueItems,\n          address = this.address;\n\n      var block = '';\n\n      if (uniqueItems === true) {\n        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is\n     * > greater than, or equal to, the value of this keyword. The length of\n     * > a string instance is defined as the number of its characters as\n     * > defined by RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength() {\n      var minLength = this.schema.minLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is less\n     * > than, or equal to, the value of this keyword. The length of a string\n     * > instance is defined as the number of its characters as defined by\n     * > RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxLength',\n    value: function maxLength() {\n      var maxLength = this.schema.maxLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Pattern\n     *\n     * @description\n     * > A string instance is considered valid if the regular expression\n     * > matches the instance successfully.\n     * > JSON Schema Validation Section 5.2.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      var pattern = this.schema.pattern,\n          address = this.address;\n\n\n      if (pattern) {\n        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n      }\n    }\n\n    /**\n     * Format\n     *\n     * @description\n     * > Structural validation alone may be insufficient to validate that\n     * > an instance meets all the requirements of an application. The\n     * > \"format\" keyword is defined to allow interoperable semantic\n     * > validation for a fixed subset of values which are accurately\n     * > described by authoritative resources, be they RFCs or other\n     * > external specifications.\n     * > JSON Schema Validation Section 7.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'format',\n    value: function format() {\n      var format = this.schema.format,\n          address = this.address;\n\n      var matcher = formats.resolve(format);\n\n      if (matcher) {\n        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n      }\n    }\n\n    /**\n     * Minimum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is greater\n     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n     * > present and has boolean value true, the instance is valid if it is\n     * > strictly greater than the value of \"minimum\".\n     * > JSON Schema Validation Section 5.1.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      var _schema3 = this.schema,\n          minimum = _schema3.minimum,\n          exclusiveMinimum = _schema3.exclusiveMinimum,\n          address = this.address;\n\n      var operator = exclusiveMinimum === true ? '<=' : '<';\n\n      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Maximum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is lower than,\n     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n     * > boolean value true, the instance is valid if it is strictly lower\n     * > than the value of \"maximum\".\n     * > JSON Schema Validation Section 5.1.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      var _schema4 = this.schema,\n          maximum = _schema4.maximum,\n          exclusiveMaximum = _schema4.exclusiveMaximum,\n          address = this.address;\n\n      var operator = exclusiveMaximum === true ? '>=' : '>';\n\n      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * multipleOf\n     *\n     * @description\n     * > A numeric instance is valid against \"multipleOf\" if the result of\n     * > the division of the instance by this keyword's value is an integer.\n     * > JSON Schema Validation Section 5.1.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'multipleOf',\n    value: function multipleOf() {\n      var multipleOf = this.schema.multipleOf;\n\n      var block = '';\n\n      if (typeof multipleOf === 'number') {\n        var length = multipleOf.toString().length;\n        var decimals = length - multipleOf.toFixed(0).length - 1;\n        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n        var condition = void 0;\n\n        if (decimals > 0) {\n          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n        } else {\n          condition = 'value % ' + multipleOf + ' !== 0';\n        }\n\n        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n  }]);\n\n  return Validator;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Validator;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Validator.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}